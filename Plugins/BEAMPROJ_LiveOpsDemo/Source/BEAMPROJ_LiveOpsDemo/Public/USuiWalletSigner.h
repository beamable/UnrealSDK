#pragma once

#include "CoreMinimal.h"
#include "SaveGameStateSui.h"
#include "AutoGen/SubSystems/BeamSuiFederationApi.h"
#include "Containers/Array.h"
#include "Containers/UnrealString.h"
#include "HAL/PlatformFilemanager.h"
#include "Misc/SecureHash.h"
#include "Engine/Engine.h"
#include "Kismet/GameplayStatics.h"

// Note: You'll need to add these third-party libraries to your UE5 project
// Add to your .Build.cs file:
// PublicDependencyModuleNames.AddRange(new string[] { "libsodium" });
// Or use UE5's built-in crypto if available in your version

// For UE5 integration, we'll use platform-specific includes
#if PLATFORM_WINDOWS
#include "Windows/AllowWindowsPlatformTypes.h"
#include <compact25519.h>
#include <blake2.h>

#include "Windows/HideWindowsPlatformTypes.h"
#elif PLATFORM_MAC || PLATFORM_LINUX
    #include <compact25519.h>
#endif

#include "USuiWalletSigner.generated.h"

UCLASS(BlueprintType, Blueprintable)
class BEAMPROJ_LIVEOPSDEMO_API USuiWalletSigner : public UObject
{
	GENERATED_BODY()
	const FString SlotName = "SlotName";

	TArray<uint8> PrivateKey;
	TArray<uint8> PublicKey;

public:
	UPROPERTY(BlueprintReadOnly)
	FString WalletId;

	/**
	 * Generating the public and private key using a library that supports the ED25519 key pair generation
	 * After generate the public and private key we are generating the wallet id.
	 * You can check the documentation for generating the wallet key in the @copydoc GenerateWalletId
	 */
	UFUNCTION(BlueprintCallable, Category = "Sui Wallet", meta=(ExpandBoolAsExecs="ReturnValue"))
	bool GenerateKeypair()
	{
		PrivateKey.SetNumUninitialized(64);
		PublicKey.SetNumUninitialized(32);
		TArray<uint8> Seed;

		for (int32 i = 0; i < 32; i++)
		{
			Seed.Add(FMath::RandRange(0, 255));
		}

		// We are using the ed25519 from https://github.com/DavyLandman/compact25519
		compact_ed25519_keygen(PrivateKey.GetData(), PublicKey.GetData(), Seed.GetData());

		WalletId = GenerateWalletId(PublicKey);

		UE_LOG(LogTemp, Display, TEXT("\nPrivate Key: %s \nPublic Key: %s \nWalletId: %s"), *BytesToHexString(PrivateKey), *BytesToHexString(PublicKey), *WalletId);
		return true;
	}


	/**
	 * Sign a message using the Sui's signing format.
	 *
	 * To sing with the Sui format we need to follow some steps
	 *	1-  Create a byte array that follow this format IntentScope | Version | App | Message Length | Message Bytes (UTF8)
	 *	2 - Get the Blake2bHash for the byte array created.
	 *	3 - So you will sign the Hash generated by the Blake2bHash.
	 *	4 - Create the byte array for SUI Final format which will be Flag | Signature (Generated in the last step) | Public Key
	 *	5 - Encode to base 64 
	 *	
	 */
	UFUNCTION(BlueprintCallable, Category = "Sui Wallet")
	FString SignMessage(const FString& Message)
	{
		// Convert FString to UTF8, because unreal strings are UTF16
		FTCHARToUTF8 UTF8String(*Message);
		TArray<uint8> MessageBytes;
		MessageBytes.Append(reinterpret_cast<const uint8*>(UTF8String.Get()), UTF8String.Length());

		// As we are sending a byte array the correct intent scope is the PersonalMessage, you can check it in the official git link.
		// https://github.com/MystenLabs/sui/blob/24678e787e8e7a7bdeeab224dd32ff7c50ad82e9/crates/shared-crypto/src/intent.rs#L181

		// As described in the intent signing page (https://docs.sui.io/concepts/cryptography/transaction-auth/intent-signing)
		// The first 3 bytes are the Intent Scope | Version | App
		// For the Version and the App we passing zero as shown in the Sui repository (https://github.com/MystenLabs/sui/blob/24678e787e8e7a7bdeeab224dd32ff7c50ad82e9/crates/shared-crypto/src/intent.rs#L134)

		TArray<uint8> SigningData;
		SigningData.Add(0x03); // Intent scope: Personal Message
		SigningData.Add(0x00); // Version: 0
		SigningData.Add(0x00); // App: 0

		// After serialize the first 3 bytes we need to serialize the message in the BCS format as shown in the https://docs.sui.io/concepts/cryptography/transaction-auth/offline-signing#serialize
		// The BCS format for string will be the serialization of the Length | Message Bytes
		SigningData.Add(static_cast<uint8>(MessageBytes.Num()));
		SigningData.Append(MessageBytes);

		// For Sui you need to sign a blake hash of the signing data
		// So we need to first generate the blake hash and then use a library of ED25519 to sign the hash.
		// https://docs.sui.io/concepts/cryptography/transaction-auth/intent-signing#user-signature

		TArray<uint8> MessageHash = Blake2bHash(SigningData);
		if (MessageHash.Num() != 32)
		{
			UE_LOG(LogTemp, Error, TEXT("Failed to hash message"));
			return FString();
		}

		// Sign the hash with Ed25519
		TArray<uint8> Signature;
		Signature.SetNumUninitialized(64);

		// We are using the ed25519 from https://github.com/DavyLandman/compact25519
		compact_ed25519_sign(Signature.GetData(), PrivateKey.GetData(),
		                     MessageHash.GetData(), MessageHash.Num());


		// Sui signature format:  signature_scheme_flag + signature_bytes (64 bytes) + public_key
		// All the details of the format are shown in the https://docs.sui.io/concepts/cryptography/transaction-auth/signatures
		// For this sample as we are using the Ed25519 the first byte will be 0x00
		// Followed by the signature bytes end then the public key
		TArray<uint8> SuiSignature;

		SuiSignature.Add(0x00);

		SuiSignature.Append(Signature);

		SuiSignature.Append(PublicKey);

		// Here we are printing all the information for debug purpose. 
		UE_LOG(LogTemp, Display, TEXT("Private Key = %s"), *BytesToHexString(PrivateKey));
		UE_LOG(LogTemp, Display, TEXT("Public Key = %s"), *BytesToHexString(PublicKey));
		UE_LOG(LogTemp, Display, TEXT("Wallet Id  = %s"), *WalletId);
		UE_LOG(LogTemp, Display, TEXT("Message Challenge = %s"), *Message);
		UE_LOG(LogTemp, Display, TEXT("Message Bytes  = %s"), *BytesToHexString(MessageBytes));
		UE_LOG(LogTemp, Display, TEXT("Message Hash  = %s"), *BytesToHexString(MessageHash));
		UE_LOG(LogTemp, Display, TEXT("Raw Signature  = %s"), *BytesToHexString(Signature));
		UE_LOG(LogTemp, Display, TEXT("Signature Sui  = %s"), *BytesToHexString(SuiSignature));

		// The sui signature NEED to be in a base 64 encoded format to be validated correctly
		// https://docs.sui.io/concepts/cryptography/transaction-auth/offline-signing#sign
		return FBase64::Encode(SuiSignature);
	}

	/**
	 * This is a verifier method just to test the signature in the current algorithm is working fine.
	 */
	UFUNCTION(BlueprintCallable, Category = "Sui Wallet")
	bool VerifySignature(const FString& Message, FString SignatureBase64) const
	{
		// If the public key is different from 32 bytes it will fail
		// Probably means you didn't made a generate key or a load private key
		if (PublicKey.Num() != 32)
		{
			UE_LOG(LogTemp, Error, TEXT("Invalid public key length"));
			return false;
		}
		TArray<uint8> SignatureBytes;

		FBase64::Decode(SignatureBase64, SignatureBytes);

		// The signature have 97 bytes
		// 1 byte from the flag
		// 64 bytes from the signature
		// 32 bytes from the public key
		if (SignatureBytes.Num() != 97)
		{
			UE_LOG(LogTemp, Error, TEXT("Invalid signature length"));
			return false;
		}

		// Extracting the signature starting in the second byte because of the flag in the first byte
		// With Size 64
		TArray<uint8> Signature;
		for (int32 i = 1; i < 65; ++i)
		{
			Signature.Add(SignatureBytes[i]);
		}

		// Recreating the Hash as in the SignMessage
		// So first we need to make sure that the message is in Utf8 as unreal defaults is Utf16
		FTCHARToUTF8 UTF8String(*Message);
		TArray<uint8> MessageBytes;
		MessageBytes.Append(reinterpret_cast<const uint8*>(UTF8String.Get()), UTF8String.Length());

		TArray<uint8> SigningData;

		// Add to the signature data Intent Scope | Version | App 
		SigningData.Add(0x03); // Intent Scope: Personal Message
		SigningData.Add(0x00); // Version: 0
		SigningData.Add(0x00); // App: 0

		// Serializing the message in the BCS Format Length | Message bytes
		SigningData.Add(static_cast<uint8>(MessageBytes.Num()));
		SigningData.Append(MessageBytes);

		// Creating the Blake 2b hash for the signing data
		TArray<uint8> MessageHash = Blake2bHash(SigningData);
		if (MessageHash.Num() != 32)
		{
			return false;
		}

		// We are using the ed25519 from https://github.com/DavyLandman/compact25519
		return compact_ed25519_verify(Signature.GetData(), PublicKey.GetData(),
		                              MessageHash.GetData(), MessageHash.Num());
	}

	/**
	 * Here we are saving the current private key locally for user be able to login
	 * This has been done only for sample purpose.
	 */
	UFUNCTION(BlueprintCallable, Category = "Sui Wallet", meta=(ExpandBoolAsExecs="ReturnValue"))
	bool SavePrivateKeyToLocalSaveData()
	{
		if (USaveGameStateSui* SuiSaveState = Cast<USaveGameStateSui>(UGameplayStatics::CreateSaveGameObject(USaveGameStateSui::StaticClass())))
		{
			SuiSaveState->PrivateKey = BytesToHexString(PrivateKey);

			return UGameplayStatics::SaveGameToSlot(SuiSaveState, SlotName, 0);
		}
		return false;
	}

	/**
	* Here is where you should put your SUI app call to get the private key and do the login.
	* In the sample we are loading from a local cached state
	*/
	UFUNCTION(BlueprintCallable, Category = "Sui Wallet", meta=(ExpandBoolAsExecs="ReturnValue"))
	bool LoadSuiPrivateFromCache()
	{
		// Load private key from cache
		if (USaveGameStateSui* SuiSaveState = Cast<USaveGameStateSui>(UGameplayStatics::LoadGameFromSlot(SlotName, 0)))
		{
			return LoadPrivateKey(SuiSaveState->PrivateKey);
		}
		else
		{
			return false;
		}
	}

	// Utilities

	/**
	* This will be useful to get the external identity info
	*	for backend calls
	*/
	UFUNCTION(BlueprintPure, Category = "SUI")
	void GetSUIExternalIdentityInfo(FString& MicroserviceId, FString& FederationId, FString& OutWalletId)
	{
		FederationId = TEXT("SuiExternalIdentity");
		MicroserviceId = GEngine->GetEngineSubsystem<UBeamSuiFederationApi>()->GetMicroserviceName();
		OutWalletId = WalletId;
	}

	/**
	 * This will be useful to get the identity info
	 * for backend calls
	 */
	UFUNCTION(BlueprintPure, Category = "SUI")
	void GetSUIIdentityInfo(FString& MicroserviceId, FString& FederationId, FString& OutWalletId)
	{
		FederationId = TEXT("SuiIdentity");
		MicroserviceId = TEXT("SuiFederation");
		OutWalletId = WalletId;
	}

	/**
	 * Here's a test utility to verify if the algorithm is working fine.
	 */
	UFUNCTION(BlueprintCallable, Category = "Sui Wallet")
	void TestSigning(FString TestMessage)
	{
		UE_LOG(LogTemp, Warning, TEXT("=== Testing Sui Wallet Signing ==="));

		if (!GenerateKeypair())
		{
			UE_LOG(LogTemp, Error, TEXT("Failed to generate keypair"));
			return;
		}

		FString Signature = SignMessage(TestMessage);

		if (Signature.IsEmpty())
		{
			UE_LOG(LogTemp, Error, TEXT("Failed to sign message"));
			return;
		}

		UE_LOG(LogTemp, Warning, TEXT("Message: %s"), *TestMessage);
		UE_LOG(LogTemp, Warning, TEXT("Signature: %s"), *Signature);

		bool bIsValid = VerifySignature(TestMessage, Signature);
		UE_LOG(LogTemp, Warning, TEXT("Signature Valid: %s"), bIsValid ? TEXT("Yes") : TEXT("No"));

		// Test with wrong message
		bool bIsInvalid = VerifySignature(TEXT("Wrong message"), Signature);
		UE_LOG(LogTemp, Warning, TEXT("Wrong Message Valid: %s"), bIsInvalid ? TEXT("Yes") : TEXT("No"));
	}

private:
	/**
	 * The load private key method is used to get the public key and the wallet id from a given private key
	 * you can check more about how to generate the wallet id in the @copydoc GenerateWalletId
	 */
	bool LoadPrivateKey(const FString& PrivateKeyHex)
	{
		if (PrivateKeyHex.Len() != 128)
		{
			UE_LOG(LogTemp, Error, TEXT("Private key must be 128 hex characters (64 bytes)"));
			return false;
		}

		TArray<uint8> KeyBytes = HexStringToBytes(PrivateKeyHex);
		if (KeyBytes.Num() != 64)
		{
			UE_LOG(LogTemp, Error, TEXT("Private key must be 64 bytes"));
			return false;
		}

		PrivateKey = KeyBytes;
		PublicKey.SetNumUninitialized(32);

		// We are using the ed25519 from https://github.com/DavyLandman/compact25519
		compact_ed25519_calc_public_key(PublicKey.GetData(), PrivateKey.GetData());
		WalletId = GenerateWalletId(PublicKey);

		return true;
	}

	/**
	 *  We are generating the Sui wallet id the same way that is generated in the official repository as the link bellow
	 *  https://github.com/MystenLabs/ts-sdks/blob/822f59cb912a03fc5c6bfd3c8b4cb53bf92e222d/packages/typescript/src/utils/sui-types.ts#L96
	 *  https://github.com/MystenLabs/ts-sdks/blob/822f59cb912a03fc5c6bfd3c8b4cb53bf92e222d/packages/typescript/src/cryptography/publickey.ts#L120
	 *
	 *  1 - First we first create a byte array that contains a (0x00) Byte | PublicKey
	 *  2 - After this we generate the Blake 2b hash from this created array.
	 *  3 - Convert to Hex and Lower it.
	 *  4 - In the end we just add the "0x" to the string to match the format of the wallet id
	*/
	FString GenerateWalletId(TArray<uint8> PublicKeyByteArray)
	{
		TArray<uint8> PublicKeyToken;

		PublicKeyToken.Add(0x00);
		PublicKeyToken.Append(PublicKeyByteArray);

		FString Token = BytesToHexString(Blake2bHash(PublicKeyToken));

		Token = Token.ToLower();

		return "0x" + Token;
	}


	/*
	 * Creating the hash using the blake 2b algorithm.
	 */
	TArray<uint8> Blake2bHash(const TArray<uint8>& Data) const
	{
		TArray<uint8> Hash;
		Hash.SetNumUninitialized(32); // 256 bits = 32 bytes

		//We are using this implementation of the blake 2b https://github.com/BLAKE2/BLAKE2
		if (blake2b(Hash.GetData(), Hash.Num(),
		            Data.GetData(), Data.Num(),
		            nullptr, 0) != 0)
		{
			UE_LOG(LogTemp, Error, TEXT("Blake2b hashing failed"));
			Hash.Empty();
		}

		return Hash;
	}

	/**
	 * Convert Hex FString to bytes
	 */
	TArray<uint8> HexStringToBytes(const FString& HexString) const
	{
		TArray<uint8> Bytes;

		if (HexString.Len() % 2 != 0)
		{
			UE_LOG(LogTemp, Error, TEXT("Invalid hex string length"));
			return Bytes;
		}

		for (int32 i = 0; i < HexString.Len(); i += 2)
		{
			FString ByteString = HexString.Mid(i, 2);
			uint8 Byte = FCString::Strtoi(*ByteString, nullptr, 16);
			Bytes.Add(Byte);
		}

		return Bytes;
	}

	// Convert Bytes to hex FString
	FString BytesToHexString(const TArray<uint8>& Bytes) const
	{
		FString HexString;
		for (uint8 Byte : Bytes)
		{
			HexString += FString::Printf(TEXT("%02x"), Byte);
		}
		return HexString;
	}
};
