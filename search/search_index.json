{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Unreal SDK","text":"<p>Welcome to the Beamable!</p> <p>The Beamable Unreal SDK provides all the functionality to integrate The Beamable Systems in your Project. It include many features such as Authentication, Content, Events, Inventory, Microservices and more.</p> <p>Here's a bit of our philosophy when desing the SDK so you know a bit what to expect:</p> The SDK's source code is entirely available and modifiable inside your project by you In case you modify the SDK's source code, we cannot guarantee that its features will work. We trust you to know when doing so might be worth it for you (VCS are your friend here). The SDK keeps itself as simple as possible, providing extension points and clear documented. We believe that tools should helpful or at least not get in your way. If you find yourself working around parts of the SDK instead of using them even with MicroServices/Storages, reach out to us. The SDK is careful about assumptions it makes. Whenever we have to make an assumption, we try to be explicit about what it means. MicroServices/Storages are great ways to \"just write what you want instead\" when using our default services is not a good fit. Blueprint and C++ Code Parity Most of our docs contains examples using Blueprints. Unless described otherwise there is option to achieve same results in C++ while following Blueprint sample. In C++, the subsystems and function names are the same except that, for lambda-binding, you'll need to use the <code>CPP_</code> versions of functions."},{"location":"#technical-requirements","title":"Technical Requirements","text":"<p>Beamable currently supports Unreal 5.4.X.</p> <p>Beamable also has a dependency on  .NET. This is needed for:</p> <ul> <li>Installing the Beamable CLI (and therefore enabling the various Beamable workflows).</li> <li>Using C# Microservices through the CLI.</li> </ul> <p>Beamable has a hard-dependency on Docker. This is needed for two things:</p> <ul> <li>Building and Deploying Beamable Microservices to your realms (dev/staging/prod environments).</li> <li>Running Beamable Microservices without opening the service's project (for non-engineers that want to run microservices locally).</li> </ul> <p>If you don't have these installed, take this opportunity to install it while you investigate these docs further.</p>"},{"location":"#mobile-and-console-support","title":"Mobile and Console Support","text":"<p>We do not provide Mobile support yet and Console support is under investigation. The current version of the SDK is focused on PC (Windows/Linux) and Dedicated Servers. Console and Mobile support will be added later</p>"},{"location":"#beamable-cli","title":"Beamable CLI","text":"<p>Most of the Beamable workflows are enabled through the Beamable CLI; our editor integrations making use of it to create Engine-specific workflows.</p> <p>The SDK is tightly integrated with the CLI in some ways more than others. For example:</p> <ul> <li>Content, being designer-focused, has its own UE-familiar content editing UI so you can edit the various JSON blobs that defines your game's content. </li> <li>Microservices, however, being more engineer focused, leans more directly on the CLI.</li> </ul> <p>In other words: The Beamable CLI is invisible to the user where it needs to be and explicit to users that need to work with them.</p>"},{"location":"#where-to-start","title":"Where to start?","text":"<p>Regardless of who you are, we recommend run through the Getting Strted, Runtime Systems Overview and Identity documents. After this, it depends on what you're game is or what you are looking to do.</p> <ul> <li>If you are a game maker looking to implement simple and common back-end features, take a look at the docs for Inventory, for currency and items, and Stats, for player-scoped key-value stores.</li> <li>If you are a game maker looking to implement highly specific features, browse the documentation for Content and Microservices to think about how to structure your game's data and custom data with Beamable.</li> <li>If you are looking to integrate Beamable into your game through Unreal's <code>IOnlineSubsystem</code>, take a look at the Online Subsystem Beamable.</li> </ul> <p>If you have any questions, feel free to contact us through one of our Customer Success channels.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will walk you through the process of setting up Beamable in your Unreal Engine project and making your first request.</p>"},{"location":"getting-started/#signing-up-account","title":"Signing Up Account","text":"<p>To start using Beamable in your project you need to have a valid Account in our Platform. you can sign-up an account in our portal.</p>"},{"location":"getting-started/#cloning-and-installing-dependencies","title":"Cloning and Installing Dependencies","text":"<p>Start by getting our repo, then installing .NET and Docker Dekstop.</p> <ol> <li>Clone UnrealSDK repo (make sure you have <code>git-lfs</code> installed).</li> <li>Check out the a tagged release version (in the form <code>X.X.X</code>).<ol> <li>Most <code>git</code> clients will allow you to checkout a specific tagged commit via their UI.</li> <li>At Beamable, we're partial to Fork.</li> </ol> </li> <li>Run the <code>prepare_repo.sh</code> script.<ol> <li>On Windows, use the GitBash that your <code>git</code> install contains.</li> </ol> </li> <li>Generating Project Files.<ol> <li>On Windows, you can right-click the\u00a0<code>.uproject</code>\u00a0file and select\u00a0<code>Generate Visual Studio project files</code>.</li> </ol> </li> <li>Optional - Verify things are working by compiling the editor of our SDK project.</li> </ol> <p>Next up, install our dependencies.</p> <ul> <li>Docker Desktop</li> <li>.NET</li> </ul> <p>Once you have our repo and dependencies set up in your machine, follow along one of the next section to set up the SDK in your project.</p>"},{"location":"getting-started/#set-up-the-beamable-sdk-fast-path","title":"Set up the Beamable SDK - Fast Path","text":"<p>Setting up the SDK in your project is done by manually copying over a set of files from our Unreal SDK repo to your project. </p> <p>Unreal Project Requirements</p> <p>Beamable requires your Unreal project to be a C++ project. That being said, we do provide an entire suite of Blueprint nodes that can be used to achieve most of the same functionality.</p> <p>Please, follow along these instructions:</p> <ol> <li>Copy the <code>beam_init_game_maker.sh</code> script into the root of your Unreal Project.</li> <li>From a terminal running in your project directory, run the copied script passing in the path to the UnrealSDK in your machine.<ol> <li><code>. beam_init_game_maker.sh \"E:/Path/To/UnrealSDK\"</code></li> <li><code>. beam_init_game_maker.sh \"E:/Path/To/UnrealSDK\" true</code>, if you're planning to use the <code>OnlineSubsystemBeamable</code>.</li> </ol> </li> <li>For each of your <code>Target.cs</code> files, add the following lines to their constructor:<ol> <li><code>MyProject.Target.cs =&gt; Beam.ConfigureGame(this, Beam.OssConfig.Disabled())</code>.</li> <li><code>MyProjectEditor.Target.cs =&gt; Beam.ConfigureEditor(this, Beam.OssConfig.Disabled())</code>.</li> <li><code>MyProjectServer.Target.cs =&gt; Beam.ConfigureServer(this, Beam.OssConfig.Disabled())</code>, if you have dedicated server builds.</li> </ol> </li> <li>In each of the Modules you want to use Beamable's SDK, add this to their <code>Build.cs</code> files:<ol> <li><code>RuntimeModule.Build.cs =&gt; Beam.AddRuntimeModuleDependencies(this);</code></li> <li><code>EditorModule.Build.cs =&gt; Beam.AddEditorModuleDependencies(this);</code></li> <li><code>UncookedOnlyModule.Build.cs =&gt; Beam.AddUncookedOnlyModuleDependencies(this);</code></li> <li>Pay attention to the type of module you're adding the SDK to and call the proper function. (You can see the module type in your <code>uproject</code> file)</li> </ol> </li> <li>Some OS-specific things:<ol> <li>On MacOS, you'll have to manually regenerate project files. </li> <li>On Windows, this was done by <code>beam_init_game_maker.sh</code> script.</li> </ol> </li> <li>Verify that your project is set up correctly:<ol> <li>Check there is a <code>.beamable</code> folder in your project root directory.</li> <li>Check there is a <code>.config/dotnet-tools.json</code> file in your project directory.</li> <li>Run <code>dotnet beam --version</code> from inside your project root directory and see that it outputs a valid <code>X.Y.Z</code> string.</li> </ol> </li> <li>Open Rider/VS and compile your editor.</li> </ol>"},{"location":"getting-started/#making-your-first-request","title":"Making your First Request","text":"<p>Once your Editor opens, you'll see the Beamable Logo in your upper-right bar, next to the Settings dropdown. This button opens the Beamable window.</p> <p></p> <p>In this window, you can login to the account you just created in the Beamable portal. When you do, you should see the window below:</p> <p></p> <p>Here's some a quick tour of Beamable terminology:</p> <ul> <li><code>Realm</code> is an isolated data environment (think of it as a branch, but for your backend). <ul> <li>By default, you have one of these these for your <code>dev</code>, <code>staging</code> and <code>prod</code> environments.</li> <li>The <code>ApplyToBuild</code> button sets the realm information in the <code>Config/DefaultEngine.ini</code> file of your project. Whatever realm is configured in this file, is the realm your build will be pointed towards. Dedicated Server Builds don't need to care about their baked in <code>TargetRealm</code>. They fetch their target realm from Environment Variables.</li> </ul> </li> <li><code>Content</code> opens up the Content Window. <ul> <li>Content is Beamable's solution for defining game-specific read-only data.</li> </ul> </li> <li><code>Microservices</code> opens the Microservice Window. <ul> <li>Microservices are Beamable's approach to Cloud-Code.</li> </ul> </li> <li><code>Reset PIE Users</code> (Play-In-Editor) removes your PIE users locally cached data. <ul> <li>By default, when you sign into a Beamable account in PIE (in your game code), Beamable will use the same user until you delete the files <code>Saved/Beamable/UserSlots/PIE_XXXXX.json</code>. </li> <li>This button does that for you. After you click it, the next time you enter PIE, a brand new Beamable player account will be created in your current realm.</li> </ul> </li> <li><code>Home</code> opens Beamable's Portal in your default web-browser.<ul> <li>You'll be logged in with your editor user and pointed at your current realm.</li> <li>The other buttons are short-cuts to pages you usually need during day-to-day workflows.</li> </ul> </li> </ul> <p>Now that you are familiar with the Beamable Window, you are ready to make your first Beamable request (we'll do it via Blueprint, but you can do the exact same flow in C++ by making these calls in your Project's <code>GameMode</code> class's <code>BeginPlay</code> function).</p> <p>To get started, open your Level Blueprint and add the following pattern:</p> <p></p> <p>The <code>BeamRuntime</code> is an <code>GameInstanceSubsystem</code> that is responsible for controlling the SDK's lifecycle and, in clients, player authentication. </p> <p>SDK Technical Overview</p> <p>The Technical Overview explains how the Beamable Runtime works. Please read it after you are done with this guide as the default Beamable configuration might not be the best fit for your type of game and it'll give you examples of common setups.</p> <p>Calling this function will initialize the SDK and, after that is successful, will automatically log into Beamable as a Guest Account. There are 3 exposed callbacks here:</p> <ul> <li><code>On Started Error</code>: This callback will be invoked if any problems occurred during the SDK's initialization process. If this is called, neither of the other two are called.</li> <li><code>On User Ready</code>: This callback will be invoked after the user is logged in and 100% ready for use; after this callback is invoked, you can make authenticated requests to Beamable.</li> <li><code>On User Ready Failed</code>: This callback will be invoked if the SDK initialized but the Login fails. You can retry by invoking any of the <code>Login</code> functions in <code>Beam Runtime</code>.</li> </ul> <p>Now that you have this event hooked up, you can add your first Beam Flow Node and make your first request. Beam Flow Nodes are custom nodes that wrap around the following flow:</p> <ul> <li>Creating a new Request <code>UObject</code>.</li> <li>Getting a <code>UBeam___Api</code> engine subsystem. <ul> <li>This is a stateless system that exposes an auto-generated API to talk to various services.</li> <li>This is not the recommended way you'll use Beamable. Its just the simplest way for you to get started.</li> </ul> </li> <li>A set of Custom Event nodes (for success, error and completion) of the request being made to Beamable.<ul> <li>Because of this, Unreal does not allow the use of these nodes (or any node that expands to Event nodes) outside of EventGraphs or Macros used in EventGraphs.</li> </ul> </li> </ul> <p></p> <p>With the SDKs default configuration and the above setup, you can enter PIE (Play-In-Editor). You should see several requests's responses being written to your Output Log window. After you see the final <code>GetMe</code> request, you can exit PIE knowing you've made your very first request to Beamable.</p>"},{"location":"getting-started/#additional-tips","title":"Additional Tips","text":"<p>Before we complete this guide, there's one final thing that is important to know. We higly recommend to use verbose logging <code>log \"Category\" Verbose</code> when  encountering an issue stemming from our SDK (Log Categories can be found in <code>BeambleCore/BeamLogging.h</code> file).</p> <p>This verbose logging will print out everything about the request being made. Its meant to aid us in diagnosing issues that you may encounter when using the SDK AND not for production use. To turn it off in the same editor session, just run <code>log LogBeamBackend Display</code> in the editor console.</p> <p>When reporting an issue, try to reproduce the issue with the logs of the relevant systems set to Verbose and attach them to the issue.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've made your first Beamable Request, take a look at the Technical Overview page so you can understand more about how the SDK is structured and identify the best path to using it in your game.</p> <p>If you'd like to see a more samples running on Beamable, take a look at our Samples.</p> <p>If you want to contact us for support, doubts or suggestions, you can do so through one of our Discord Channel. </p>"},{"location":"samples/discord-demo/","title":"Discord Integration Sample","text":"<p>This demo, showcases how you can use the Unreal SDK and Beamable Microservices to integrate with Discord for community management tools.</p>"},{"location":"samples/discord-demo/#introduction","title":"Introduction","text":"<p>Aside from our <code>BeamableCore</code> Plugin, here's what the sample contains:</p> <ul> <li><code>BEAMPROJ_DiscordDemo</code> Unreal Plugin.: Contains the UE implementation for the client.</li> <li><code>Microservices/services/DiscordDemo</code> Microservice: Microservice containing code that implements IFederatedLogin and a <code>DiscordBot</code> integration.</li> </ul> <p>To set up this sample you'll need a few things:</p> <ul> <li>A Beamable Account and a Realm.</li> <li>A Discord Developer Account.</li> </ul> <p>To configure the sample, run <code>dotnet beam unreal select-sample BEAMPROJ_DiscordDemo</code>.</p> <p>Assumptions</p> <p>Instructions below assume that you already have the Discord server that you want to use for integration. If that is not the case create one first. Make sure that you have the admin access to the Discord server of choice.</p>"},{"location":"samples/discord-demo/#setting-discord-application","title":"Setting Discord Application","text":"<p>Since this sample requires several resources, we do not host it ourselves. So, in order to access the sample we'll go set up a Discord account and setup the sample Discord bot:</p> <ol> <li>Log into your Discord.dev account.</li> <li>Create an App. Set aside its <code>AppId</code> in a notepad for future use.<ol> <li>Fill out General Information about your app.</li> <li>No need for providing any of the URLs at the bottom of the General Information page.</li> </ol> </li> <li>Go to App <code>Settings-&gt;OAuth2</code> and set the Redirects Url: <code>http://127.0.0.1</code>. Make sure that changes are saved.</li> <li>Go to App <code>Settings-&gt;Bot</code>.<ol> <li>Set a Bot username.</li> <li>Set as true all Privileged Gateway Intents, especially the Server Members Intent.</li> <li>Press the <code>Reset Token</code> button and set it aside (it will be required later on).</li> </ol> </li> <li>Go to App <code>Settings-&gt;Installation</code>.<ol> <li>In <code>Install Link</code> select <code>Discord Provided Link</code>, copy and paste it into browser.</li> <li>In <code>Default Install Settings</code> add <code>bot</code> to the <code>Scopes</code> field and <code>Administrator</code> to the <code>Permissions</code> field</li> <li>Install the App into your Discord server of choice.</li> </ol> </li> <li>Now open the Discord application.<ol> <li>Open <code>Settings-&gt;Advanced</code> and enable the <code>Developer Mode</code> so that we can copy various Ids by right-clicking things in the UI.</li> <li>Right click on the server icon and select the option <code>Copy server ID</code> and set it aside.</li> <li>Right click on the server icon and select <code>Settings-&gt;Roles</code>. </li> <li>Create a <code>enabled-matchmaking</code> role.</li> <li>Right click on the role and select the option <code>Copy Role ID</code> and set it aside.</li> <li>Pick any text channel. Right click on the channel select the option <code>Copy Channel ID</code> and set it aside.</li> </ol> </li> </ol>"},{"location":"samples/discord-demo/#setting-up-beamable","title":"Setting up Beamable","text":"<p>Now, you'll need to configure a Beamable realm so you can use it.</p> <ol> <li>Go to the Beamable Portal and create a new Beamable realm called <code>discord-demo</code>.</li> <li>On the Portal open the Realm Config page of the <code>discord-demo</code> realm (<code>Operate -&gt; Config</code>).</li> <li>Hit the <code>Add Config</code> button.</li> <li>Set the following key-value pairs for the namespace <code>discord_integration</code>:<ol> <li><code>matchmaking_roles_whitelist -&gt; Your copied Role Id, can be multiple separated by comma</code></li> <li><code>bot_token -&gt; Your Bot Token</code></li> <li><code>guild_id -&gt; Your Discord Server ID</code> </li> <li><code>notify_channel -&gt; Optional- Discord channel ID that bot will notify about status changes</code> </li> </ol> </li> <li>Open the <code>Plugins/BEAMPROJ_DiscordDemo/Overrides/Config/DefaultGame.ini</code>. <ol> <li>Replace the <code>DiscordAppId</code> in it with <code>Your App Id</code>.</li> <li>Regenerate project files.</li> </ol> </li> <li>Compile and open the <code>BeamableUnreal</code> editor (it'll be configured as the <code>BEAMPROJ_DiscordDemo</code>) project.</li> </ol> <p>Now, you are ready to sign into a game using Discord.</p>"},{"location":"samples/discord-demo/#playing-the-sample-in-editor","title":"Playing the sample in Editor","text":"<p>In order to test the sample:</p> <ol> <li>Open the <code>BeamableUnreal</code> in the Unreal Editor</li> <li>Sign into your Beamable account in the <code>Beamable Window</code> and go to the <code>discord-demo</code> realm.</li> <li>Go to the <code>Microservices</code> and run the <code>DiscordSampleMS</code> microservice.</li> <li>Start game.</li> <li>Press the <code>Sign In with Discord</code> button following instructions (discord will ask for permission).</li> <li>After logging in, you should see information about being able to participate in matchmaking.</li> <li>Adding and/or removing the role to the signed in user on Discord Server.</li> <li>Observe the text on the UI changing to reflect your ability to participate in matchmaking.</li> <li>Also, if <code>notify_channel</code> was specified correctly in configuration bot should inform about status change:</li> </ol> <p></p> <p>In order to actually gate matchmaking you'll need to set up a rule in your <code>GameType</code> content that excludes people from the queue that do not have the role. This is not shown on this demo.</p>"},{"location":"samples/discord-demo/#can-i-use-it-as-a-template","title":"Can I use it as a Template?","text":"<p>This sample is not meant to be used as a template directly, however, its components are free for you to copy and use in your own project. Here's what these are:</p> <ul> <li>The <code>DiscordDemo</code> Microservice.</li> <li>Beamable code inside <code>BEAMPROJ_DiscordDemo</code> except code inside a <code>ThirdParty</code> directory.</li> <li>Content inside the <code>BEAMPROJ_DiscordDemo</code> except things inside a <code>ThirdParty</code> directory.</li> </ul>"},{"location":"samples/discord-demo/#why-dont-we-provide-a-client-build","title":"Why don't we provide a client build?","text":"<p>Because clients must be pointed at your <code>discord-demo</code> realm. As such, you'd need to generate the build yourself, which you can do by packaging it normally for any of our supported platforms.</p>"},{"location":"samples/hathora-demo/","title":"Hatora Integration Sample","text":"<p>This demo, created from UE's FPS Template, show-cases how you can use the Unreal SDK, OnlineSubsystemBeamable and Beamable Microservices to integrate with Hathora (a game server orchestration provider).</p>"},{"location":"samples/hathora-demo/#introduction","title":"Introduction","text":"<p>Aside from our <code>BeamableCore</code> Plugin and assets from the FPS Template, here's what the sample contains:</p> <ul> <li><code>BEAMPROJ_HathoraDemo</code> Unreal Plugin.: Contains the UE implementation for the game-server and client.</li> <li><code>Microservice/HathoraDemo</code> Microservice: Microservice containing code that ties Beamable's matchmaking system and Hathora's Game Server Orchestration system.</li> <li>Pre-Built Linux Dedicated Server Binaries: Building dedicated servers is time-consuming so... we give you a build that can be configured via Environment Variables so you can test the sample as fast as possible.</li> <li><code>OnlineSubsystemBeamable/Customer/**</code> Extension: Code added to the <code>OnlineSubsystemBeamable</code> plugin to extend our implementation of <code>IOnlineSubsystem</code> interfaces with code specific to the Hathora demo.</li> </ul> <p>To set up this sample you'll need a few things:</p> <ul> <li>A Beamable Account and a Realm.</li> <li>A Hathora Account.</li> <li>A downloaded build (link to git-hub action artifacts of release tag build).</li> </ul> <p>To configure the sample, run <code>dotnet beam unreal select-sample BEAMPROJ_HathoraDemo</code>.</p>"},{"location":"samples/hathora-demo/#setting-up-beamable-hathora","title":"Setting up Beamable &amp; Hathora","text":"<p>Since this sample requires several resources, we do not host it ourselves. So, in order to access the sample you'll need to configure a Beamable realm so you can use it.</p> <ol> <li>Go to the Beamable Portal and create a new Beamable realm called <code>hathora-demo</code>.</li> <li>Go to the Portal (<code>Account</code>) and set aside your Customer Id (CID).</li> <li>Go to the Portal and set aside your realm's PID and Realm Secret (<code>Games -&gt; YourGame -&gt; hathora-demo</code>).</li> <li>Compile and open the <code>BeamableUnreal</code> editor (it'll be configured as the <code>BEAMPROJ_HathoraDemo</code>) project.</li> <li>Sign into your Beamable account and go to the <code>hathora-demo</code> realm.<ol> <li>Hit <code>Apply to Build</code>.</li> </ol> </li> <li>Open the <code>Content Window</code>.<ol> <li>Verify that there are two <code>game_types</code>: <code>solo_queue</code> and <code>training</code>.</li> </ol> </li> <li>Hit <code>Publish</code> and wait. </li> <li>Go to the Portal (<code>Operate -&gt; Content</code>) and verify that the content is there.</li> <li>Open a bash terminal at the <code>BeamableUnreal</code> root directory.</li> <li>Run <code>dotnet beam project enable --with-group BEAMPROJ_HathoraDemo</code></li> <li>Run <code>dotnet beam project disable --without-group BEAMPROJ_HathoraDemo</code></li> <li>Guarantee <code>Docker</code> is open and running.</li> <li>Run <code>dotnet beam deploy plan</code>. <ol> <li>This tells you details about the services you would deploy given your project's local state.</li> </ol> </li> <li>Run <code>dotnet beam deploy release --latest-plan</code>. <ol> <li>This deploys the services outlined by the generated plan in the previous command. </li> </ol> </li> <li>Go to the Portal (<code>Operate -&gt; Microservices</code>) to verify that the microservices have initialized.</li> </ol> <p>Now, we'll go set up a Hathora account and upload the sample dedicated server build:</p> <ol> <li>Log into your Hathora account.</li> <li>Create an App and set aside its <code>AppId</code>.</li> <li>In the Hathora Portal, go to <code>Profile -&gt; Settings</code>.</li> <li>Create and set aside two tokens: <code>game-server</code> and <code>matchmaking-server</code>.</li> <li>Deploy a new version by uploading the .tar file we provided for the sample.<ol> <li>Configure the <code>Instance Profile</code> as a \"medium\".</li> </ol> </li> <li>Set up the following environment variables with the values you set aside:<ol> <li><code>BEAMABLE_CUSTOMER_OVERRIDE</code> = <code>Your CustomerId (CID)</code></li> <li><code>BEAMABLE_REALM_OVERRIDE</code> = <code>Your hathora-demo Realm's PID</code></li> <li><code>BEAMABLE_REALM_SECRET</code> = <code>You hathora-demo Realm's Secret</code></li> <li><code>BEAMABLE_ENVIRONMENT_OVERRIDE</code> = <code>BeamProdEnv</code></li> <li><code>HATHORA_DEV_TOKEN</code> = <code>The game-server dev token</code>.</li> </ol> </li> <li>Make sure the <code>7777</code> UDP port is exposed.</li> <li>Make sure that the number of rooms per processes is <code>1</code>.</li> <li>Finish the deployment process and verify that the deployment was successful.</li> </ol> <p>Realms and Hathora</p> <p>Hathora recommends users create one Hathora account per dev-environment. In Beamable, that is equivalent of having one Hathora account per Beamable Realm; one for dev, another for staging and yet another for prod. This is so you can have multiple deployments up at the same time for different purposes (the live deployment in prod vs a QA-testing build in staging and the current stable/nightly in dev).</p> <p>Now that your Hathora account is configured to boot up our provided build, we need to configure the <code>hathora-demo</code> realm with the information it needs to correctly provision a server whenever a match is made.</p> <ol> <li>Go to the Beamable Portal and open the Realm Config page of the <code>hathora-demo</code> realm (<code>Operate -&gt; Config</code>).</li> <li>Hit the <code>Add Config</code> button.</li> <li>Set the following key-value pairs for the namespace <code>hathora_integration</code>.<ol> <li><code>app_id -&gt; Your Hathora AppId</code></li> <li><code>dev_token -&gt; Your matchmaking-server dev token</code> </li> </ol> </li> </ol> <p>Now, you are ready to join a match through PIE.</p>"},{"location":"samples/hathora-demo/#playing-the-sample-through-pie","title":"Playing the sample through PIE","text":"<p>In order to play the sample using a dedicated server in Hathora:</p> <ol> <li>Set your <code>Multiplayer Options -&gt; NetMode</code> to <code>Play as Standalone</code> and open the <code>Hathora Demo</code> map.<ol> <li>If you can't find it, turn on <code>Content Browser -&gt; Settings -&gt; Show Plugin Content</code> and look inside the <code>BEAMPROJ_HathoraDemo</code> content folder.</li> </ol> </li> <li>Run PIE.</li> <li>The first time you are running, type in an email/password and hit register. <ol> <li>In subsequent runs OR if you use the same email/password as your Beamable account, hit Login instead.</li> </ol> </li> <li>After you're signed in, hit the <code>Training</code> button and observe the logs. If you look at Hathora's Portal, you'll be able to see the server spinning up for you to play in. If you look at the your Microservice logs (<code>Operate -&gt; Microservice -&gt; HathoraDemo -&gt; Logs</code>), you'll be able to see its communication with Hathora.</li> <li>After a match is found --- 30 seconds later you'll connect to the actual server and see the match. </li> <li>Move around a while and then simply PIE.</li> </ol> <p>Cold Starts</p> <p>The first run of the application might time out due. If that happens, simply wait until you see a log line in the UE Log window that says \"DeleteTicket\" show up and simply re-join the queue.</p> <p>To test this out with two players (this is max players for this sample):</p> <ol> <li>Set your <code>Multiplayer Options -&gt; NetMode</code> to <code>Play as Client</code> and your <code>Multiplayer Options -&gt; Number of Players</code> to <code>2</code>.</li> <li>Sign into different accounts in each PIE instance.</li> <li>Hit the <code>Solo Queue</code> button instead of the <code>Training</code> one in both PIE instances.</li> <li>Wait for a bit and both PIE instances will be matched against each other.</li> </ol>"},{"location":"samples/hathora-demo/#known-issue-network-version-mismatch","title":"Known Issue - Network Version Mismatch","text":"<p>There's a known issue that'll prevent you from actually getting PIE to connect to the Hathora URL; its an version mismatch problem with the Linux Build we generate. The error is called <code>OutdatedClient</code> --- and was seen even when the versions should be matching exactly. This is being actively investigated and a fix should be released in the next version.</p> <p>You can still see the entire flow happening. - If you look at your UE client logs, you can see that you correctly receive the lobby information with a valid Hathora connection string. - If you look at your Hathora Console, you can see the room being created and even the connection attempt.</p> <p>So there's still some value in looking into this sample in this version until this is fixed so we opted to release it anyway.</p>"},{"location":"samples/hathora-demo/#can-i-use-it-as-a-template","title":"Can I use it as a Template?","text":"<p>This sample is not meant to be used as a template directly, however, its components are free for you to copy and use in your own project. Here's what these are:</p> <p>However, its Beamable code components are free for you to copy and use in your own project. Here's what these are:</p> <ul> <li>The HathoraDemo Microservice.</li> <li>Beamable code inside <code>BEAMPROJ_HathoraDemo</code> except code inside a <code>ThirdParty</code> directory.</li> <li>Content inside the <code>BEAMPROJ_HathoraDemo</code> except things inside a <code>ThirdParty</code> directory.</li> </ul>"},{"location":"samples/hathora-demo/#why-dont-we-provide-a-client-build","title":"Why don't we provide a client build?","text":"<p>Because clients must be pointed at your organization's <code>hathora-demo</code> realm. As such, you'd need to generate the build yourself, which you can do by packaging it normally for any of our supported platforms.</p>"},{"location":"samples/intro/","title":"Setting Up The Sample Projects","text":"<p>Beamable provides sample projects for Unreal as part of the Unreal SDK repository. Each sample is tied to a plugin named <code>BEAMPROJ_&lt;PluginName&gt;</code> of a shared <code>BeamableUnreal</code> project. The sample you see in the editor is determined by which <code>BEAMPROJ_</code> plugin is enabled in the BeamableUnreal.uproject file.</p>"},{"location":"samples/intro/#preparing-the-environment","title":"Preparing the Environment","text":"<ol> <li>Install Dependencies<ul> <li>NET 8.0</li> <li>Docker Desktop</li> </ul> </li> <li>Clone the UnrealSDK Repository<ul> <li>Clone the UnrealSDK repository if you didn't yet.</li> <li>Run the <code>prepare_repo.sh</code> Script. (We recommend using GitBash, but any similar shell should work)</li> </ul> </li> </ol>"},{"location":"samples/intro/#select-the-sample-to-run","title":"Select the Sample to Run","text":"<ol> <li>Use <code>dotnet beam unreal select-sample BEAMPROJ_&lt;PluginName&gt;</code> to switch to the plugin (and thus the sample) you want. During this process all of the content in their <code>Override</code> folder will be copied to the <code>BeamamableUnreal</code> project replacing any previous configuration. This allow us to replace the whole \"Context\" in which the project will be configured, thus allowing us to have multiple samples at the same project.</li> <li>For example, <code>dotnet beam unreal select-sample BEAMPROJ_HathoraDemo</code> switches the repo to the Hathora Demo sample</li> <li>If using Rider as IDE and already in the BeamableUnreal.sln project you can alternatively select and run the <code>SET BEAMPROJ - &lt;PluginName&gt;</code> in the Configuration Drop Down (Top Right Corner)</li> </ol>"},{"location":"samples/intro/#build-and-run-in-editor","title":"Build and Run in Editor","text":"<ol> <li>Open the generated <code>.sln</code> file in your IDE (e.g., Visual Studio, Rider...).</li> <li>Perform a Clean build of the Editor target.</li> <li>Run the <code>BeamableUnreal</code> Project and in the editor, go to Project Settings \u2192 Beamable Core \u2192 Beamable Environment and verify it\u2019s set to <code>BeamProdEnv</code>.</li> <li>Sign in to your Beamable account in the Beamable Window.</li> <li>Follow Sample-Specific Instructions. Each sample has its own documentation for additional steps or guidance.</li> </ol> <p>Clean Up Sample Realms</p> <p>If you are using your own organization (the one you\u2019ll use to ship your game) to test any of these samples, don\u2019t forget to delete the test realms when you\u2019re finished exploring!</p>"},{"location":"samples/intro/#why-using-a-single-repository","title":"Why Using a Single Repository?","text":"<p>We keep all Beamable samples within the main repository so we can:</p> <ul> <li>Use as QA Tools: We continuously develop and test against our own samples.</li> <li>Ensure Up-to-Date Samples: Whenever we update the SDK, the sample projects are updated too. Maintaining samples alongside core features makes it easier to keep everything stable and consistent.</li> </ul> <p>To make this work as should we keep the <code>Config</code> and <code>.beamable</code> folders in sync. This is done by:</p> <ul> <li>Our custom <code>Target.cs</code> code that will make the <code>Config</code> and <code>.beamable</code> folders at the root level of the repo be exact copies of the folders inside the <code>Overrides</code> directory of each <code>BEAMPROJ_</code> folder. In other words, the contents of those folders at the root level is defined by the selected <code>BEAMPROJ</code>.</li> <li>An editor subsystem called <code>BeamProjSync</code> that, while the editor is running, file-watches those directories and copies changes made over to the appropriate <code>BEAMPROJ_</code> <code>Overrides</code> folder.</li> <li>Those implementations are only related to the especificity of this sample configuration and it's not related to the samples content themselves.</li> </ul>"},{"location":"samples/live-ops-demo/","title":"LiveOps Sample","text":"<p>This demo showcases how you can use the Beamable Unreal SDK's in LiveOps game projects. Particularly it focus on the Player Stats, Announcements and Inventory Systems.</p> <p></p>"},{"location":"samples/live-ops-demo/#introduction","title":"Introduction","text":"<p>Aside from our <code>BeamableCore</code> Plugin, here's what the sample contains:</p> <ul> <li><code>BEAMPROJ_LiveOpsDemo</code> Unreal Plugin.: Contains the UE implementation for the sample's client. The core code is inside <code>LiveOpsDemoMainMenu.h</code> and part of the implementation is done through BPs inside the folder <code>UI_BPs</code> folder of the <code>BEAMPROJ_LiveOpsDemo</code> project.</li> <li><code>Microservice/LiveOpsDemo</code> Microservice: Microservice containing code that's used by the sample for various inventory and stat related things.</li> </ul> <p>To set up this sample you'll need a a Beamable Account and a Realm. To configure the repo for the sample run <code>dotnet beam unreal select-sample BEAMPROJ_LiveOpsDemo</code>.</p>"},{"location":"samples/live-ops-demo/#setting-up-the-project","title":"Setting up the Project","text":"<p>To set up an organization and realm to run this sample, follow the steps below.</p> <ol> <li>Go to the Beamable Portal and create a new Beamable realm called <code>liveops-demo</code> </li> <li>Compile and open the <code>BeamableUnreal</code> editor project.</li> <li>Sign into your Beamable account and go to the <code>liveops-demo</code> realm.<ol> <li>Optionally you can hit <code>Apply to Build</code> after the realm change is done.</li> </ol> </li> <li>Let's Setup the Content<ol> <li>Open the <code>Content</code> window.</li> <li>Ensure there's an <code>item</code> content with the name <code>sample_item</code></li> <li>Ensure there are 2 <code>currency</code> contents with names <code>gems</code> and <code>coins</code></li> <li>Click <code>Publish</code> to publish those new contents to the realm.</li> <li>You can read more about the content system Here</li> </ol> </li> <li>Now let's setup the Announcements<ol> <li>Open the Beamable Portal.</li> <li>Choose <code>liveops-demo</code> realm from Beamable portal.</li> <li>Go to <code>Communicate-&gt;Campaigns</code>.</li> <li>Click on Create Campaign.</li> <li>Initialize the campaign scheduling, content, and the gifts it provides and save it.         1. Make sure the type is <code>Announcement</code>.         2. In the <code>Content</code> section, add a Gift that gives some amount of <code>coin</code> to the user. Optionally, you can also gift them an instance of the <code>sample_item</code> with a property called <code>level</code> set to <code>1</code>.         3. You can leave the rest as the default.</li> </ol> </li> </ol>"},{"location":"samples/live-ops-demo/#running-the-sample-in-editor","title":"Running the Sample in Editor","text":"<p>Now you're set up to run the sample.</p> <ol> <li>Open the Unreal editor.</li> <li>Go to the <code>Beamable -&gt; Microservice</code> window.<ol> <li>You should see the <code>LiveOpsDemoMS</code> service there. Select it.</li> <li>Click <code>Run</code> and wait until you see the <code>Service ready for traffic</code> log line (and the running icon in the Microservice's card to change).</li> <li>After you're done with the sample, don't forget to come here and stop the service.</li> </ol> </li> <li>Reset PIE Users to clear any existing data.<ol> <li>Go to the <code>Home</code> window.</li> <li>Click on <code>Reset PIE Users</code>.</li> </ol> </li> <li>Open the <code>LiveOpsDemo</code> Level if it's not opened yet.<ol> <li>You can find it inside the <code>BEAMPROJ_LiveOpsDemo Content</code>  folder.</li> <li>If you can't see plugin content in your content browser, you can change the settings of the UE <code>Content Browser</code> to display it.</li> </ol> </li> <li>Play the <code>LiveOpsDemo</code> in the Editor.</li> </ol>"},{"location":"samples/live-ops-demo/#tips-and-tricks","title":"Tips and Tricks","text":"<p>At runtime, the sample works in the following way:</p> <ol> <li>Every time you run the demo, it will initialize the player inventory with 3 sample items that have the an item property called <code>level</code> set to <code>1</code>.    </li> <li>It'll also initialize a Stat <code>sample_stat</code> with the value <code>1</code>. <ol> <li>You can also click the button next to the <code>sample stat</code> stat to increment it.</li> </ol> </li> <li>In the announcements page, you'll find all the announcements you configured via the portal (provided the schedule you put in makes it active). <ol> <li>You can click on any announcement.</li> <li>Doing so, shows its content and all the rewards/gifts that could be claimed through this announcement (if any).</li> <li>You can claim the gifts inside the announcement by clicking on the claim button.    </li> </ol> </li> <li>In the Inventory page, You can see each of the <code>sample_item</code> instances the player has and their level at the right portion of the screen.<ol> <li>You should be able to upgrade the item level using the upgrade button.</li> </ol> </li> </ol>"},{"location":"samples/live-ops-demo/#can-i-use-it-as-a-template","title":"Can I use it as a Template?","text":"<p>This sample is not meant to be used as a template directly, however, its components are free for you to copy and use in your own project. Here's what these are:</p> <ul> <li>The LiveOpsDemoMS Microservice : located inside Microservice/LiveOpsDemoMS</li> <li>Beamable code and blueprints inside BEAMPROJ_LiveOpsDemo plugin</li> </ul>"},{"location":"samples/steam-demo/","title":"Steam Integration Sample","text":"<p>This demo showcases how you can use the Unreal SDK and Beamable Microservices to integrate with Steam.</p>"},{"location":"samples/steam-demo/#introduction","title":"Introduction","text":"<p>Aside from our <code>BeamableCore</code> Plugin, here's what the sample contains:</p> <ul> <li><code>BEAMPROJ_SteamDemo</code> Unreal Plugin.: Contains the UE implementation for the client.</li> <li><code>Microservices/services/SteamDemo</code> Microservice: Microservice containing code that implements IFederatedLogin</li> </ul> <p>To set up this sample you'll need a few things:</p> <ul> <li>A Beamable Account and a Realm.</li> <li>A Steam Developer Account.</li> </ul> <p>To configure the sample, run <code>dotnet beam unreal select-sample BEAMPROJ_SteamDemo</code>.</p> <p>Assumptions</p> <p>Instructions below assume that you already have the Steam application created, if that is not the case create one first.</p>"},{"location":"samples/steam-demo/#setting-steam-application","title":"Setting Steam Application","text":"<p>Since this sample requires several resources, we do not host it ourselves. So, in order to access the sample we'll go set up a Steam account and setup the sample:</p> <ol> <li>Log into your Steam developer account.</li> <li>Go to your App and set aside its <code>AppId</code>.</li> <li>Create a Publisher Web API key using this tutorial. Set it aside in a notepad for future use.</li> <li>Make sure that game is added to user that you want to use to login. To do that:<ol> <li>Generate a Steam Key.</li> <li>Add it to your Steam account so you can access the game.</li> </ol> </li> </ol>"},{"location":"samples/steam-demo/#setting-up-beamable-systems","title":"Setting up Beamable Systems","text":"<p>Now, you'll need to configure a Beamable realm so you can use it:</p> <ol> <li>Go to the Beamable Portal and create a new Beamable realm called <code>steam-demo</code>.</li> <li>Go to the Portal (<code>Account</code>) and set aside your Customer Id (CID).</li> <li>Go to the Portal and set aside your realm's PID and Realm Secret (<code>Games -&gt; YourGame -&gt; steam-demo</code>).</li> <li>On the Portal open the Realm Config page of the <code>steam-demo</code> realm (<code>Operate -&gt; Config</code>).</li> <li>Hit the <code>Add Config</code> button.</li> <li>Set the following key-value pairs for the namespace <code>steam</code>:</li> <li><code>appid -&gt; Your Steam application ID</code></li> <li><code>key -&gt; Your Steam Application Publisher Key</code> </li> <li>Compile and open the <code>BeamableUnreal</code> editor (it'll be configured as the <code>BEAMPROJ_SteamDemo</code>) project.</li> <li>Sign into your Beamable account and go to the <code>steam-demo</code> realm.<ol> <li>Hit <code>Apply to Build</code>.</li> </ol> </li> <li>Open a bash terminal at the <code>BeamableUnreal</code> root directory.</li> <li>Run <code>dotnet beam project enable --with-group BEAMPROJ_SteamDemo</code></li> <li>Run <code>dotnet beam project disable --without-group BEAMPROJ_SteamDemo</code></li> <li>Guarantee <code>Docker</code> is open and running.</li> <li>Run <code>dotnet beam deploy plan</code>. <ol> <li>This tells you details about the services you would deploy given your project's local state.</li> </ol> </li> <li>Run <code>dotnet beam deploy release --latest-plan</code>. <ol> <li>This deploys the services outlined by the generated plan in the previous command. </li> </ol> </li> <li>Go to the Portal (<code>Operate -&gt; Microservices</code>) to verify that the microservices have initialized.</li> <li>In <code>DefaultEngine.ini</code> set the value of <code>SteamDevAppId</code> to your Steam Application ID. For more there tutorial here.</li> <li>Package the project.</li> <li>In main folder (in the built game's folder where the executable is) create <code>steam_appid.txt</code> file with Steam Application ID as only content.</li> </ol> <p>Now, you are ready to sign into a game using Steam.</p>"},{"location":"samples/steam-demo/#playing-the-sample","title":"Playing the sample","text":"<p>Testing the Steam integration from the editor should be performed in <code>Standalone Game</code> mode. </p> <p>Steam integration can encounter challenges when running in PIE mode. For this reason,   Microservice needs to be deployed as local development of federation only works with PIE when not in Standalone Game mode.</p> <p>In order to test the sample:</p> <ul> <li>Start game with Steam open with the account to which you added the game.</li> <li>It should automatically try to login to that account.</li> <li>You should see your \"Steam\" status change to playing.</li> </ul>"},{"location":"samples/steam-demo/#can-i-use-it-as-a-template","title":"Can I use it as a Template?","text":"<p>This sample is NOT a template you can start your own repository from. However, its Beamable code components are free for you to copy and use in your own project. Here's what these are:</p> <ul> <li>The <code>SteamDemo</code> Microservice.</li> <li>Beamable code inside <code>BEAMPROJ_SteamDemo</code> except code inside a <code>ThirdParty</code> directory.</li> <li>Content inside the <code>BEAMPROJ_SteamDemo</code> except things inside a <code>ThirdParty</code> directory.</li> </ul>"},{"location":"samples/steam-demo/#why-dont-we-provide-a-client-build","title":"Why don't we provide a client build?","text":"<p>Because clients must be pointed at your <code>steam-demo</code> realm. As such, you'd need to generate the build yourself, which you can do by packaging it normally for any of our supported platforms.</p>"},{"location":"user-reference/overview/","title":"SDK Technical Overview","text":"<p>The Beamable SDK is a collection of custom UE <code>Engine</code>, <code>Editor</code> and <code>GameInstance</code> Subsystems. Game-Maker Code (as in, code the Beamable customer writes) can take advantage of various guarantees we provide by understanding how these subsystems work.</p> <p>The SDK's Plugin is divided into several modules:</p> <ul> <li>BeamableCore contains the <code>UEngineSubsystem</code> implementations shared between <code>Editor</code> and <code>Runtime</code> executing environments.  It also contains the <code>UBeamContentObject</code> schema definitions for our content system.</li> <li>BeamableCoreRuntime contains the <code>UBeamRuntime</code> and <code>UBeamRuntimeSubsystem</code> implementations and manage the SDK lifecycle at runtime.</li> <li>BeamableCoreEditor and BeamableCoreRuntimeEditor contains <code>UBeamEditor</code> and our editor integration code: custom BlueprintNodes, PropertyCustomizations, etc...</li> </ul> <p>For any technical lead (making system-level decisions), effective use of Beamable and the Unreal SDK requires you to understand a few core concepts. So, after reading this document, you'll want to start here:</p> <ul> <li>Content is how you define your game's configuration --- balancing data, currency and item definitions, etc... Most of our systems depend on Content so, its a good place to start.</li> <li>Identity the various ways you can manage a player's account and login flows.</li> <li>Microservices are our version of cloud-code --- but also much more.</li> <li>Federation are effectively exposed hooks in our backend's various features that you can hook into with custom behavior. You can leverage this for integrating with third-party authentication, initial player state and a lot more. </li> </ul> <p>Aside from those core concepts, the links below explain some of our higher-level systems.</p> <ul> <li>Stats and Inventory are our general-case player-data stores. You can use these to store player-related data and implement a variety of features with them.</li> <li>Matchmaking and Lobbies are part of our suite of services for real-time multiplayer games.</li> <li>Stores and Announcements are part of our suite of services to help with live-ops meta-game engagement.</li> </ul>"},{"location":"user-reference/overview/#sdks-runtime-ubeamruntime-ubeamruntimesubsystem","title":"SDK's Runtime (<code>UBeamRuntime</code> &amp; <code>UBeamRuntimeSubsystem</code>)","text":"<p><code>UBeamRuntime</code> is the entry point for the Beamable SDK at runtime (PIE, packaged game clients and dedicated servers). It is a <code>GameInstanceSubsystem</code> and follows its lifecycle rules.  It is responsible for a couple of things:</p> <ul> <li>It controls the SDK's runtime initialization flow.</li> <li>It controls the various SDK's user [un]-authentication flows.</li> <li>It controls <code>UBeamRuntimeSubsystems'</code> lifecycle with respect to the SDK's initialization flow itself and <code>FUserSlot</code> authentication.</li> </ul> <p>The image below describes how the SDK's lifecycle injects itself into UE's lifecycle:</p> <p></p> <p>The next image shows a high-level description of the authentication flows supported by the SDK:</p> <p></p>"},{"location":"user-reference/overview/#understanding-beamruntimesubsystems","title":"Understanding <code>BeamRuntimeSubsystems</code>","text":"<p><code>BeamRuntimeSubsystems</code> are stateful subsystems that provide some specific Beamable functionality.  They are built on top of our auto-generated <code>UBeam____Api</code> classes to make it simpler to leverage our APIs; that way:</p> <ol> <li>You don't have to set up the common case.</li> <li>You can use them and their extension points for variations of the common case.</li> <li>You can use them as reference implementations to implement your own custom use cases.</li> </ol> <p>These are handwritten. Here's a few examples:</p> <ul> <li><code>UBeamStatsSubsystem</code>: This enables you to store arbitrary key-value pairs associated to a player's account.</li> <li><code>UBeamInventorySubsystem</code>: This provides builder functions around our Inventory APIs that allows you to combine what would be multiple API requests into a single batched inventory update. It also receives inventory notifications coming from the server and keeps those in sync.</li> <li><code>UBeamMatchmakingSubsystem</code>: This provides you a stateful way of joining/canceling a matchmaking queue and receiving updates when a match is found.</li> </ul> <p>These systems make use of the various <code>UBeamRuntime::____</code> callbacks to keep their state correct and expose callbacks and configuration options for Game-Maker Code to run with semantically relevant guarantees.</p> <p>If the exposed hooks on these are not enough for your use case and constraints, as a user you can create your own <code>UBeamRuntimeSubsystem</code>.  The SDK does not obfuscate its inner-workings from you so you can use the existing <code>UBeamRuntimeSubsystems</code> as a reference to understand how to create your own. The documentation in Lower Level SDK and Operations &amp; Waits can also be useful when implementing your own <code>UBeamRuntimeSubsystems</code>. </p> <p>You can also opt out of these entirely by adding them to <code>UBeamCoreSettings</code> 's property: <code>ManuallyInitializedRuntimeSubsystems</code>. All subsystems in this list, and any other subsystem that depends on it, are not automatically initialized by the SDK. For example, if <code>UBeamInventorySubsystem</code> is in this list, this system will not be usable until you manually initialize it. </p> <p>You can leverage the above to:</p> <ul> <li>Delay initialization of subsystems to a later point to reduce startup times.</li> <li>Remove our implementation of a set of systems so that you can use your own implementation of those systems without paying the overhead of our default implementations.</li> <li>Disable systems that you do not want to use to reduce the SDK's request overhead.</li> </ul> <p>Keep in mind that the simplest way is to build your features on top of these subsystems instead of replacing them. However, there are complex cases where it may be easier to make your own system instead of these subsystems.  That's why we allow you to enable/disable systems with this granularity.</p>"},{"location":"user-reference/beamable-services/announcements/","title":"Announcements","text":""},{"location":"user-reference/beamable-services/announcements/#overview","title":"Overview","text":"<p>The Beamable SDK Announcement feature allows players view and receive game-wide announcements configured by the Game-Makers. A few of the main use cases are:</p> <ul> <li>Communicating to Players information about the game's live operations that are relevant.</li> <li>Targeting a Subset of Players with gifts or compensations due to things that happen over the course of your live-game services.</li> </ul> <p>Announcements can be created via the portal.</p> <p>Once created, announcements stay live during the specified date-times. While live, each player has a \"view\" of that announcement. This view defines whether the player has seen that announcement or claimed any gifts contained in them.</p> <p>These are exposed in the <code>UAnnouncementView</code> object which can be accessed by the <code>UBeamAnnouncementsSubsystem::GetAnnouncements</code> method.</p>"},{"location":"user-reference/beamable-services/announcements/#claiming-an-announcements-gifts-and-marking-as-read","title":"Claiming an Announcement's Gifts and Marking as Read","text":"<p>It is common to attach gifts to announcements so that players can claim them. To do so, you can use the <code>ClaimAnnouncementsOperation</code> passing in the list of announcement ids (<code>UAnnouncementView::Id</code>).</p> <p>The image below shows how this can be done in blueprint.</p> <p></p> <p>Marking announcements as read can be achieved in a similar way but with the <code>MarkAnnouncementsReadOperation</code>. The image below shows how you would mark an announcement as read when a user clicks one and a popup opens displaying its details.</p> <p></p>"},{"location":"user-reference/beamable-services/announcements/#usage-guidelines","title":"Usage Guidelines","text":"<p>Aside from the <code>Id</code> most other <code>FString</code> fields in the announcement can be used to store whatever data you need. Common practices include:</p> <ul> <li>Passing in <code>TSoftObjectPath</code> strings to reference in-game assets.</li> <li>Passing in some custom string format such that your UI interprets it and change its behavior accordingly.</li> <li>Use <code>ClientDataList</code> to pass in key-value pairs of arbitrary string data based on your game's context.</li> <li>So on...</li> </ul> <p>Our system itself and the SDK doesn't really care about the format or content of the <code>Title</code>, <code>Summary</code> or <code>Body</code> fields so feel free to use them as needed (they are merely semantic suggestions of what an announcement contains).  </p>"},{"location":"user-reference/beamable-services/content/","title":"Content System","text":"<p>Beamable Content System is a read-only (at runtime) arbitrary data store that allows you to define arbitrary JSON-serialized content objects for use at runtime. Several of Beamable's own managed features also use content in some way or another.</p>"},{"location":"user-reference/beamable-services/content/#overview","title":"Overview","text":"<p>The system is manifest-based. This means:</p> <ul> <li>That a manifest is an list of published content objects in a realm indexed by their content ids.</li> <li>That publishing a manifest means first uploading all the individual content objects to Beamable and, after that, uploading a manifest that knows all where each content lives.</li> <li>That downloading a manifest does not necessarily imply downloading the individual content object jsons (more information below).</li> </ul> <p>We don't provide server-side schema enforcing which means you are solely responsible for maintaining backward compatibility for your custom content objects.</p> <p>Each individual content object in each manifest is identified by an ID with the format below:</p> <p>ContentTypeId.ContentName</p> <p><code>ContentType</code> expands to the hierarchy of <code>UBeamContentObject</code> types, starting from the root type. For example:</p> <p><code>UMyGameItemContent</code> inherits from <code>UBeamItemContent</code> <code>items.mygameitem.MyGameItemName</code></p> <p>The last part of the id is the only one you should edit through the Content Window.</p>"},{"location":"user-reference/beamable-services/content/#content-window","title":"Content Window","text":"<p>The content window is the main tool to create, edit and publish new content to your project.</p> <p></p> <p>The list of content objects displayed in the content window is very similar to a \"Status\" window in Git or some other version control systems. Beside show your local content it also present the differences between your local state and the state in your currently targeted <code>Realm</code>.</p> <p>These differences are represented by the <code>[+]</code>,<code>[-]</code> and <code>[M]</code> signs.</p> <ul> <li><code>[+]</code>: Means the content exists locally but NOT in the realm.</li> <li><code>[M]</code>: Means the content exists BOTH locally and in the realm AND that it is modified relative to the one in the realm.</li> <li><code>[-]</code>: Means the content DOES NOT exists locally but DOES exist in the realm.</li> </ul> <p>If the content is not marked with any of these signs, it means it is in sync with the realm.</p> <p>Changing Realm</p> <p>Changing Realms does NOT auto-sync your local content with that realm's content. This means that you will see changes to these (<code>[+]</code>, <code>[M]</code>, <code>[NC]</code>, <code>[-]</code>) signs to reflect their new status against the new target realm.</p> <p>Where can I find the content files?</p> <p>While you edit the content objects as <code>UObject</code> and a details panel, these are not stored as <code>UDataAsset</code> or anything inside Unreal itself. These are stored as individual JSON objects inside <code>ProjectRoot/.beamable/content/global</code> folder. This makes it more friendly for version control systems.</p>"},{"location":"user-reference/beamable-services/content/#creating-and-deleting-content","title":"Creating and Deleting Content","text":"<p>To create a new piece of content Locally:</p> <ol> <li>Select a content type from the Type dropdown.</li> <li>Type in a name for the content; it cannot contain whitespaces or <code>.</code>.</li> <li>Click the <code>Create</code> button.</li> </ol> <p>Deleting content can be done simply by pressing <code>Del</code> on your keyboard with a item selected or clicking the <code>Delete</code> button in the Item Details.</p> <p>Items created locally will have a <code>[+]</code> sign next to them informing that they are not in the realm yet and will be added in the next publish.</p> <p>Items deleted locally that have counterparts on the realm will have a <code>[-]</code> sign next to them informing that they will be removed from the realm in the next publish.</p>"},{"location":"user-reference/beamable-services/content/#downloading-and-publishing","title":"Downloading and Publishing","text":"<p>To sync your local content with the realm, you have to Download and Publish.</p> <p>Download will collect all content from the realm, adding new content, replacing any <code>[M]</code> and restoring any <code>[-]</code> values to match the ones in the realm. It is similar to selecting all non-new files in a version control and \"discarding changes\".</p> <p>Publish is similar to a commit. This will make the content in the realm the same as your local content. After publish, all pieces of content will match the realm and <code>[-]</code> content should disappear.</p> <p>Publishing is a Destructive Operation</p> <p>Publishing replace all the content in the Realm with your local content. This means that if you have multiple users (Designers for example) working on the same realm, you might override each other's changes if you don't Download before Publishing. We highly recommend each user working in content to work in your own realm.</p> <p>Workflow for Working as a Team</p> <p>Here is a sample worklow for a team of multiple developers:</p> <ul> <li>Each developer has it own Realm (Example: Realm1, Realm2, Realm3)</li> <li>The <code>Dev</code> Branch (If using Git) of the project is the Source of Truth shared for all developers, and each developer is working on this branch</li> <li>Each Developer tests their changes on their own realm and when done commits those changes to the <code>Dev</code> Branch so the rest of team can have access to this.</li> <li>After pulling the <code>Dev</code> Branch, each developer should publish the new version of the content to their realms,so here can keep working in sync with the Dev branch.</li> </ul>"},{"location":"user-reference/beamable-services/content/#ubeamcontentobject-and-custom-content-types","title":"<code>UBeamContentObject</code> and Custom Content Types","text":"<p>In Unreal, you define content schemas as sub-classes of <code>UBeamContentObject</code> or any of its sub-types available in the SDK ( <code>UBeamItemContent</code> , <code>UBeamGameTypeContent</code> , etc...). Every content type must define a unique string id for that particular type and a function that returns it.</p> <p>The following example of <code>UBeamCurrencyContent</code> shows how that can be done:</p> <pre><code>UCLASS(BlueprintType)\nclass BEAMABLECORE_API UBeamCurrencyContent : public UBeamContentObject\n{\n    GENERATED_BODY()\npublic:\n    // Define the ContentTypeId for this type.\n    UFUNCTION()\n    void GetContentType_UBeamCurrencyContent(FString&amp; Result){ Result = TEXT(\"currency\"); }\n\n    // Define the properties you wish\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    FBeamClientPermission clientPermission;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    int64 startingAmount;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"Federation\")\n    FOptionalBeamFederation external;\n};\n</code></pre> <p>Please remember to annotate your <code>UPROPERTY</code> with <code>EditAnywhere</code> and either:</p> <ul> <li><code>BlueprintReadOnly</code> if you are not writing utilities to create the objects for you.</li> <li><code>BlueprintReadWrite</code> if you are writing utilities to create the objects for you.</li> </ul> <p>Microservices</p> <p>In a lot of cases, you will want to access these content objects in Microservices.  For all of Beamable's own content-types ( <code>UBeamCurrencyContent</code> , etc...) you will find equivalents in the Microservice SDK. For your own custom types, you'll need to declare them in C#. To do so, use the serialization table below as reference to know how to map types from C++ to C#.</p>"},{"location":"user-reference/beamable-services/content/#supported-content-serialization","title":"Supported Content Serialization","text":"Serializable Type In C# Microservices Notes Primitive Types <code>uint8</code> , <code>int32</code> , and <code>int64</code> <code>byte</code>, <code>int</code> and <code>long</code>. <code>float</code> and <code>double</code>. <code>bool</code> Unreal Types <code>FString</code>, <code>FText</code>, <code>FName</code> <code>string</code> These get serialized as JSON strings. <code>FGameplayTag</code> <code>string</code> <code>FGameplayTag::RequestGameplayTag</code> for deserialization. <code>FGameplayTagContainer</code> <code>string</code> <code>FGameplayTagContainer::FromExportString</code> for deserialization. <code>UClass*</code> <code>string</code> Gets converted to <code>FSoftObjectPath</code> when serializing. Deserializing will first create the <code>FSoftObjectPath</code> and then resolve it. <code>TSoftObjectPtr</code> <code>string</code> Gets converted to <code>FSoftObjectPath</code> when serializing. When <code>None</code> serializes as an empty <code>string</code>. <code>TArray&lt;&gt;</code> <code>List&lt;&gt;</code> or <code>T[]</code> Any <code>TArray&lt;SomeType&gt;</code> will serialize normally as long as <code>SomeType</code> is also supported. <code>TMap&lt;FString, &gt;</code> <code>Dictionary&lt;string,&gt;</code> We only support maps with <code>FString</code> as keys. The values can be any supported type. Beamable Types <code>FBeamOptional</code> <code>Optional____</code> Any property of a type implementing <code>FBeamOptional</code> doesn't get serialized if <code>IsSet==false</code> but does get serialized otherwise.For example, <code>FOptionalInt32</code> serializes to nothing OR an <code>int32</code>. <code>FBeamSemanticType</code> <code>string</code> OR semantic type equivalent in C# This always gets serialized as a JSON blob when inside <code>UBeamContentObject</code>. <code>FBeamArray</code> and <code>FBeamMap</code> <code>ArrayOf</code> and <code>MapOf</code> Any implementation of these wrappers are serialized correctly as JSON arrays and JSONobjects respectively. These are only used whenyou want to nest <code>TArray&lt;TArray&lt;&gt;&gt;</code> / <code>TMap&lt;,TMap&lt;&gt;&gt;</code> and still have Blueprint Support. <code>FBeamJsonSerializableUStruct</code> Any C# class that maps to your struct Any type inheriting from this type gets serialized as a JSON object. <code>IBeamJsonSerializableUObject</code> Any C# class that maps to your class <code>UObject</code> in content should have their classesannotated with <code>DefaultToInstanced</code>,<code>EditInlineNew</code> since you shouldn't referenceassets directly inside content objects.For that, use <code>TSoftObjectPtr&lt;&gt;</code>. <p>Take a look at <code>UMockBeamContentObject</code> to see the supported types.</p>"},{"location":"user-reference/beamable-services/content/#runtime-lifecycle","title":"Runtime LifeCycle","text":"<p>The SDK fetches the content manifest before the <code>OnBeamableStarted</code> callback is triggered. By default, it downloads the content manifest and each individual piece of content. You can enable and disable this behavior it can be configured to do so inside <code>Project Settings -&gt; Beamable Runtime</code>.</p> <p></p> <p>The SDK also supports live content updates (if you publish content while the game client is running):</p> <ul> <li>While signed in to Beamable, <code>UBeamContentSubsystem</code> listens for notifications that the realm's content manifest has been updated.</li> <li>If that happens, we will re-download the manifest. </li> <li>If the SDK is configured to download individual content pieces automatically, we do so for all changed content.<ul> <li>These updates are cached locally inside the <code>Saved</code> directory in binary form such that a user does not need to re-download content in subsequent runs of your game unless the published manifest changes.</li> </ul> </li> <li>If you disable this setting, you'll have to control fetching the actual content objects yourself.<ul> <li>There are APIs you can use to manually download individual content pieces: <code>FetchIndividualContentBatchOperation</code> and <code>FetchIndividualContentOperation</code>.</li> <li>Caching will still occur when manually downloading content.</li> </ul> </li> </ul>"},{"location":"user-reference/beamable-services/content/#baking-content","title":"Baking Content","text":"<p>In a couple of cases, you might want to bake content to distribute it with your build:</p> <ul> <li>If you plan to release a new build every time you want to update your game.</li> <li>If you want to trade off some binary size for spending less time waiting for the individual content download at initialization time.</li> </ul> <p>To enable those cases, we provide an editor utility that will bake your local content into a <code>UBeamContentCache</code>.  This is a special asset type that has the <code>UBeamContentObject</code> instances serialized using UE's binary serialization as opposed to JSON. Keep in mind that this utility uses your local content; so make sure your content matches the realm's content before running it.</p> <p>The utility is called <code>EBP_BakeContent</code> and can be found in Beamable Core's plugin folder under <code>/Editor/Utility/EBP_BakeContent.EBP_BakeContent</code>.  Running this utility goes through your local content and bakes them into a <code>BCC_</code> assets ( <code>UBeamContentCache</code> ) stored in <code>/Game/Beamable/Content/Manifests/Cooked/</code> directory. This directory is configured, by default, to be included in packaged games.</p> <p>At runtime, any <code>UBeamContentCache</code> is loaded automatically by the <code>UBeamContentSubsystem</code> if it exists and is configured correctly; so you don't have to do anything to have it work.</p> <p>I can't find the Beamable Core Content in the Content Browser</p> <p>UE's Content Browser does not show Plugin content folders by default. If you want to see these, you need to turn it on at <code>Content Browser -&gt; Settings -&gt; Show Plugin Content</code>.</p>"},{"location":"user-reference/beamable-services/content/#notes-on-binary-serialization","title":"Notes on Binary Serialization","text":"<p>Unreal's Binary serialization of <code>UObject</code> types works mostly out of the box without any need for you to write any code. However, in cases where you have inlined (<code>DefaultToInstanced, EditInlineNew</code>) <code>IBeamJsonSerializableUObject</code> types inside your <code>UBeamContentObject</code> subtype's schema, you'll need to write two things to support caching content of these types:</p> <ul> <li>Override the <code>virtual void Serialize(FArchive&amp; Ar) override</code> function of the inlined <code>IBeamJsonSerializableUObject</code> type.</li> <li>Override the <code>virtual void SerializeUObjects(FArchive&amp; Ar) override</code> function of the <code>UBeamContentObject</code> subtype that contains in its schema the inlined <code>IBeamJsonSerializableUObject</code>.</li> </ul> <p>In most cases, you should prefer using <code>FBeamJsonSerializableUStruct</code> subtypes <code>UBeamContentObject</code> as these will automatically support binary serialization. It is only in cases where you need a recursive type that we recommend the use of inlined <code>IBeamJsonSerializableUObject</code>.</p> <p>For examples of handling this edge case, you can look at the <code>UBeamGameTypeContent</code> and <code>UBeamStatComparisonRule</code> types shipped with the SDK.</p>"},{"location":"user-reference/beamable-services/identity/","title":"Identity","text":"<p>The Beamable SDK comes with a set of pre-implemented operations for common sign-up use-cases. Here are how to set up a few of the common login/signup flows using Beamable.</p> <p>Identity and Dedicated Servers</p> <p>None of these flows run in Dedicated Servers; even if <code>InitSDKWithFrictionlessLogin</code> is called. Dedicated Servers use a different form of authentication that is not based on <code>FUserSlot</code> (any valid user slot can be passed into functions in Dedicated Server code).</p>"},{"location":"user-reference/beamable-services/identity/#login-flow-mobile-games-style-authentication","title":"Login Flow - \"Mobile Games\" Style Authentication","text":"<p>Mobile games often want to create a Guest Account for the player so they can start playing quickly and later decide if they want to <code>Attach</code> that guest account to a more permanent identity.</p> <p>The SDK supports this flow via the <code>UBeamRuntime::InitSDKWithFrictionlessLogin</code> function. Initializing the SDK with this function will immediately attempt to create a Guest Account at the <code>OwnerPlayerSlot</code> as soon as the SDK finishes initializing itself. If an account is already locally cached at that <code>FUserSlot</code> we'll login to that one automatically without making a request to Beamable.</p> <p>The <code>On User Ready</code> callback provided to the <code>InitSDKWithFrictionlessLogin</code> function runs after the Guest Account was successfully created and, at that point, you can make further requests to Beamable.</p> <p>Guest Accounts are lost if signed out (or have its locally cached data lost for any reason).  To avoid that, players can to \"attach\" some persistent identity information to that guest account.<code>UBeamRuntime::Attach_____</code> functions do that.</p> <p>Attaching an identity can succeed or fail:</p> <ul> <li>After a successful <code>UBeamRuntime::Attach_____</code> call, a player will be able to log in via the corresponding <code>UBeamRuntime::Login____</code> operation. <ul> <li>For example, if you <code>AttachEmailAndPassword</code> you'll be able to <code>LoginEmailAndPassword</code> to sign back into the account.</li> </ul> </li> <li>If it fails with a <code>(...)_IN_USE</code> error code, it means that the identity is already in use. Handling of this is game specific, but most games will either:<ul> <li>Call the <code>UBeamRuntime::Login____</code> and log in with the in-use identity, discarding the guest account. This is the most common way to handle this.</li> <li>Detect progress on the guest account and, if above a particular threshold, leverage microservices to try and do some progress merging should the user want it.    This is non-trivial and not a lot of games do it since cost-benefit isn't there in most cases (but it is possible).</li> </ul> </li> </ul> <p>You can check out our Discord sample for an example of this flow.</p>"},{"location":"user-reference/beamable-services/identity/#login-flow-pcconsole-style-authentication","title":"Login Flow - \"PC/Console\" Style Authentication","text":"<p>In PC/Console titles, often the user can sign-in and up from inside the game. That can happen either through an active form-filling process, an active request to third-party authentication (Discord, Google, etc...) or an automatic store-based login (Epic Online Services, PSN, Steam, etc...).</p> <p>If your game has these flows, we recommend you use <code>InitSDK</code> and manage the login/signup flows in your game code instead. The steps below explain how to do that.</p> <ul> <li>In your <code>BeginPlay</code> implementation, call <code>UBeamRuntime::InitSDK</code>. <ul> <li>It provides you different callbacks to handle initialization success or failure.</li> </ul> </li> <li>At the end of a successful initialization, you can call <code>UBeamRuntime::SignUp____</code> or <code>UBeamRuntime::Login____</code> Operations with the appropriate parameters to log in a user.<ul> <li>Most of the time, this will be our <code>ExternalIdentity</code> functions. For more information on how to use these, see Federated Login. </li> </ul> </li> <li>You can react to the successful Login/SignUp either via registering a callback to <code>UBeamRuntime::OnUserReady</code> OR by the operation's own events</li> </ul> <p>These operations are atomic inside the SDK and will clear any invalid partial state in case of any failure during their internal process. In other words, <code>UBeamRuntime::OnUserReady</code> is only in the case that the user is fully ready for use.</p> <p>You can check out our Steam sample for an example of this flow.</p>"},{"location":"user-reference/beamable-services/inventory/","title":"Inventory","text":""},{"location":"user-reference/beamable-services/inventory/#overview","title":"Overview","text":"<p>The Beamable Inventory Feature allows game makers to associate fungible and non-fungible content to individual players within the game.</p> <ul> <li>Fungible means that each instance of that content is not unique. The simplest example is a Soft/Hard Currency in a live-services game. Each coin you grant the player is not unique. In Beamable, this type of content is represented as a <code>UBeamCurrencyContent</code>.</li> <li>Non-Fungible means that each instance of that content is unique. The simplest example is an item in an MMORPG. Each instance of that item is unique and can have its own properties. In Beamable, this type of content is represented as a <code>UBeamItemContent</code>.</li> </ul> <p>Beamable's Inventory system is built on Beamable's Content Feature. This means that content can be created, edited and published via the Content Window, then granted to players through various workflows:</p> <ul> <li>Add/Remove currencies or items to the active player during the course of gameplay. <ul> <li>Ex. the player earns a new \"Sword\" inventory item based on in-game progress.</li> </ul> </li> <li>Add inventory items to the active player via the Beamable Store. <ul> <li>Ex. the player pays some currency to buy a new \"Sword\" inventory item.</li> </ul> </li> </ul>"},{"location":"user-reference/beamable-services/inventory/#data-concepts","title":"Data Concepts","text":"<p>Inventory manages two types of data: items and virtual currencies.  One thing that both have in common is that during creation of each of them it is up to game maker to decide how they can be added to player inventory by specifying <code>clientPermission</code> field:</p> <ul> <li>When toggled, the content becomes Client-Authoritative. The SDK allows game-clients to add/remove that item or currency to the player inventory directly. If your game does not include networked multiplayer and can tolerate cheating, allowing the client to read and write their own currencies is the simplest option.</li> <li>If not toggled, the content becomes Server-Authoritative. Trying to add/remove that item or currency to the player inventory from a game-client directly results in an error. The item/currencies are still readable in the game-client. To add/remove items and currencies that are Server-Authoritative, do so via a Microservice and a <code>ClientCallable</code>. </li> </ul> <p>Edit player Inventory via Portal</p> <p>Regardlesss of the value of the <code>clientPermission</code> field it is possible to view and modify players inventory through the Portal. More info here.</p>"},{"location":"user-reference/beamable-services/inventory/#virtual-currencies","title":"Virtual Currencies","text":"<p>Currencies are used to buy items with our Store system (e.g., Gold). It can also be used to symbolize the player's progress through the game, such as experience points (XP).</p> <p>In the Unreal SDK, currencies are represented by the <code>UBeamCurrencyContent</code>. Each currency can specify a <code>startingAmount</code> that is used to pre-seed player accounts with that amount of currency.</p> <p>You can subclass this content type if you want to add more information to currency that is specific to your like, such as UI related <code>ObjectPaths</code> and other references to assets that might be relevant to your game. </p>"},{"location":"user-reference/beamable-services/inventory/#items","title":"Items","text":"<p>The Items feature allows for the creation and management of various in-game objects, such as equipment, consumables, and resources.</p> <p>In the Unreal SDK, items are represented by the <code>UBeamItemContent</code> type.  You can subclass this content type to add game-specific information to item content which is then accessible via the <code>UBeamContentSubsystem</code> and in Microservices.</p>"},{"location":"user-reference/beamable-services/inventory/#item-state","title":"Item State","text":"<p>Each item instance inside a player's inventory is represented by <code>FBeamItemState</code>. These instances have the following properties:</p> <ul> <li>ContentId: The Id of <code>UBeamItemContent</code> that represents the type of this item instance.</li> <li>Properties: A key-value store of properties of this specific item instance. You control which properties exist here.</li> <li>InstanceId: A unique id of item instance inside this player's inventory.</li> </ul> <p>Rest of the fields:</p> <ul> <li>CreatedAt: when item instance was created.</li> <li>UpdatedAt: last edit date.</li> <li>FederatedId: See Inventory Federation for more information about this field.</li> </ul>"},{"location":"user-reference/beamable-services/inventory/#getting-started","title":"Getting Started","text":"<p>To use the inventory system, you will need to first:</p> <ol> <li>Go to the Content Window.</li> <li>Select <code>item</code> as a type.</li> <li>Create an item content definition.</li> <li>Select <code>currency</code> as a type.</li> <li>Create an currency content definition.</li> <li>For this guide, make sure their <code>Client Permission</code> property is set to <code>true</code>.</li> <li>Publish this content to the realm.</li> </ol> <p>Now that you have items and currencies published, follow the steps below to create a BP function that adds some currencies and grants an item to the player:</p> <ol> <li>Open your Level Blueprint (or some other BP).</li> <li>Get the <code>BeamInventorySubsystem</code></li> <li>Call <code>BeginInventoryUpdate</code>. This begins building a set of changes we will submit to the Beamable backend later.</li> <li>Call <code>PrepareAddCurrency</code> and <code>PrepareAddItem</code> selecting the currency and item types you created.</li> <li>Call the <code>Commit Inventory Update</code> operation.</li> </ol> <p>Now, call this function while a user is signed in to grant the currency/item to the player.</p> Logging in <p>Make sure that user is logged in when you call this function. See Identity</p> <p></p> <p>After running the above function at least once, you should be able to see the results of these calls in the Beamable portal. To do so:</p> <ul> <li>Set aside the <code>Gamertag/UserId</code> from the Unreal Engine logs.</li> <li>Click <code>Open Portal</code> in Beamable window.</li> <li>Go to <code>Engage-&gt;Players</code> and search for the player via <code>Gamertag/UserId</code>.</li> <li>Go to <code>Inventory</code> and see that the appropriate currency and items are inside the user's inventory. </li> </ul> <p></p>"},{"location":"user-reference/beamable-services/inventory/#performance-guidelines","title":"Performance Guidelines","text":""},{"location":"user-reference/beamable-services/inventory/#batching-updates","title":"Batching updates","text":"<p>In the getting started example, we make a new <code>FBeamInventoryUpdateCommand</code> and commit it right away. It is desirable, for both performance and latency reasons, to batch as many inventory changes as possible as long as it makes sense for your game's design. So, if you're game's feature allows for a \"edit multiple, commit later\" pattern of UX, leveraging this API is the most efficient way to go about it.</p>"},{"location":"user-reference/beamable-services/inventory/#item-instance-properties","title":"Item Instance Properties","text":"<p>As with most key-value pairs for arbitrary data, try to follow the guidelines below:</p> <ul> <li>For Keys:<ul> <li>8-20 characters are ideal (purely for human ergonomics).</li> <li>Keeping them under a few hundred characters is best for performance.</li> <li>Use enforce-able and recognizable patterns for your keys.<ul> <li>Bad: <code>ItemEnhancementName</code> and <code>ENH_Count</code></li> <li>Good: <code>ENHANCE_Name</code> and <code>ENHANCE_Count</code> OR <code>ItemEnhancementName</code> and <code>ItemEnhancementCount</code>.</li> </ul> </li> <li>Keeping your project organized is key.</li> </ul> </li> <li>For Values:<ul> <li>Values should be no more than a few hundred characters long.</li> </ul> </li> </ul> <p>If you need larger complex data structures, we recommend you use Micro Storages instead of this key-value store. This is especially true if you do NOT need to use the data in these properties at the same time as you need the list of items; for example, a list view which then opens some sort of details view. This reduces pressure on the inventory service and can help reduce latency of inventory query requests.</p>"},{"location":"user-reference/beamable-services/lobbies/","title":"Lobby","text":"<p>Beamable's Lobby system can be used primarily for 2 cases:</p> <ul> <li>Open/Closed Custom Lobbies/Rooms: Player-created custom rooms for room-based games</li> <li>Resulting Matchmaking Matches: Matchmaking queues output lobbies with players in them at each matchmaking queue. See more in Matchmaking.</li> </ul> <p>Conceptually, Lobbies are room containing only online players and a set of arbitrary room properties and player properties. There are a few rules you should be aware off:</p> <ul> <li>Each Non-Matchmaking Lobby has a Host and other Players.</li> <li>Becoming offline will remove you from the lobby (after a small delay).</li> <li>The host player becoming offline will disband a lobby (after a small delay).</li> <li>The host player can edit global properties and any other player's properties.</li> <li>The host player can kick other players whereas regular players can only leave themselves.</li> <li>Players can read the entire lobby data but only write to their own state.</li> <li>Matchmaking Result Lobbies have no host; instead they disband once every player is offline.</li> </ul> <p>We'll focus on how lobbies work and which operations can be made within them.</p>"},{"location":"user-reference/beamable-services/lobbies/#lobby-types-and-schema","title":"Lobby Types and Schema","text":"<p>There are two types of lobbies: Open and Closed lobbies. Open lobbies can be queried via <code>RefreshLobbies</code> and joined without the use of any passcode. Closed lobbies are not visible to <code>RefreshLobbies</code> and expect to be joined via the generated passcode.</p> <p>Both lobby types have the same schema and are represented by the <code>ULobby</code> class. This class has several properties:</p> <ul> <li>LobbyId: The unique identifier for the Lobby.</li> <li>MatchType: Contains information about the <code>UBeamGameTypeContent</code> that is associated with the lobby.</li> <li>Name and Description: Are arbitrarily defined when the lobby is created.<ul> <li>For matchmaking, these are empty.</li> </ul> </li> <li>Host: The host player's <code>FBeamGamerTag</code>. <ul> <li>For matchmaking result lobbies, there is no host. // Federation thing: Make a section here explaining LoL-style matchmaking where player properties change after the match is made but BEFORE the server is provisioned.</li> </ul> </li> <li>Restriction: Defines whether the lobby is Open or Closed.<ul> <li>Can be changed --- whenever it is changed to Closed, a new Passcode is generated.</li> </ul> </li> <li>Passcode: An auto-generated realm-scoped unique value that can be use to <code>JoinLobbyByPasscode</code>.<ul> <li>This is filled on-creation and the passcode length has a minimum of 6.</li> </ul> </li> <li>MaxPlayers: Defines the maximum amount of players that can be in this lobby at the same time.<ul> <li>When changing this via <code>CommitLobbyUpdateOperation</code>, if you have more players than the new MaxPlayer value, you'll get an error.</li> </ul> </li> <li>Players: A list of <code>ULobbyPlayer</code> containing data associated to each player in the lobby.<ul> <li>PlayerId: The player's <code>FBeamGamerTag</code>.</li> <li>Joined: A ISO-8601 Date Time string for when the player.</li> <li>Tags: An array of Key-Value pairs (allows duplicates).</li> </ul> </li> <li>Data: An arbitrary data store that can be filled and updated by the host of the lobby.<ul> <li>Can be filled via Federations as well.</li> </ul> </li> <li>Created: A ISO-8601 Date Time string for when the Lobby was created.</li> </ul>"},{"location":"user-reference/beamable-services/lobbies/#hosting-lobbies","title":"Hosting Lobbies","text":"<p>To use the SDK to enable a player to host a Beamable Lobby, you'll need the following:</p> <ul> <li><code>CreateOpenLobbyOperation</code> OR <code>CreateClosedLobbyOperation</code> to create the actual lobby.</li> <li><code>UpdatePlayerDataOperation</code>, <code>DeletePlayerDataOperation</code> and <code>KickPlayerOperation</code> to manage players and their in-lobby data.</li> <li><code>CommitLobbyUpdateOperation</code> to manage lobby settings and <code>Data</code>.<ul> <li>This can be used in conjunction with <code>TryBeginUpdateLobby</code> and the set of <code>Prepare____</code> functions to batch the changes along in order to minimize requests made.</li> </ul> </li> <li>For dedicated server games, use <code>ProvisionGameServerOperation</code> and Federation to boot up a server instance for the game.</li> </ul> <p>About Parties</p> <p>Only the party leader is allowed to create a Lobby. Doing so will also places all party members into the created Lobby.</p>"},{"location":"user-reference/beamable-services/lobbies/#hosts-disbanding","title":"Hosts &amp; Disbanding","text":"<p>By default, whenever a host leaves the lobby, Beamable will disband the lobby and notify all players in it. However, in some games, the desired behavior is different:</p> <ul> <li>Leader Leaves the Lobby</li> <li>Another Player in the Lobby is Promoted to Leader.</li> </ul> <p>This can be accomplished by using the SDKs <code>TryBeginUpdateLobby</code>, <code>PrepareUpdateHost</code> and <code>CommitLobbyUpdateOperation</code> before using the <code>LeaveLobbyOperation</code> to exit the lobby.</p>"},{"location":"user-reference/beamable-services/lobbies/#joining-lobbies","title":"Joining Lobbies","text":"<p>To use the SDK to enable a player to join and manage its settings inside a Beamable Lobby, you'll need the following:</p> <ul> <li><code>RefreshLobbyOperation</code>, <code>KnownLobbies</code> and <code>JoinLobbyOperation</code> to find and join an Open lobby.</li> <li><code>JoinLobbyByPasscodeOperation</code> to join an existing Closed lobby.</li> <li><code>UpdateSlotPlayerDataOperation</code> and <code>DeleteSlotPlayerDataOperation</code>.</li> <li><code>LeaveLobbyOperation</code> to leave the lobby should you want to step out of it.</li> </ul> <p>About Parties</p> <p>Only the party leader is allowed to join a Lobby. Doing so will also bring all other party members into the Lobby with them. If the Lobby MaxPlayer count would be surpassed by the entire party joining, nobody can join.</p>"},{"location":"user-reference/beamable-services/lobbies/#synchronizing-across-clients","title":"Synchronizing across Clients","text":"<p>Beamable's Lobby system will automatically notify every player inside a lobby of relevant events. Once you're in a lobby, the SDK keeps track of your local state inside <code>UBeamLobbyState</code> (one per-<code>UserSlot</code>). </p> <p>You can use <code>GetCurrentSlotLobbyState</code> to get the <code>UBeamLobbyState</code> and setup various Delegates in this object to respond the these events, normally updating your UI or custom system built on top of this subsystem. </p> <p>What to Sync?</p> <p>The actual <code>ULobby</code> is kept in-sync by the Beamable SDK! You need only update your UI or custom system data in response to things happening in the lobby system.</p> <p>Here's the list of events we expose:</p> <ul> <li>OnKickedFromLobby: Received whenever a host removes a player from the lobby via <code>KickPlayerOperation</code>.<ul> <li>Every player in the lobby receives this notification, including the host.</li> </ul> </li> <li>OnLeftLobby: Received whenever a player leaves the lobby via <code>LeaveLobbyOperation</code>.<ul> <li>Every remaining player in the lobby receives this notification.</li> </ul> </li> <li>OnLobbyDisbanded: Received whenever the host player leaves.<ul> <li>Every remaining player in the lobby receives this notification. The host does not receive it.</li> </ul> </li> <li>OnLobbyUpdate: Whenever any property of the lobby changes via <code>CommitLobbyUpdateOperation</code>, <code>UpdatePlayerDataOperation</code> and <code>UpdateSlotPlayerDataOperation</code>, this will be invoked.</li> </ul>"},{"location":"user-reference/beamable-services/matchmaking/","title":"Matchmaking","text":""},{"location":"user-reference/beamable-services/matchmaking/#overview","title":"Overview","text":"<p>The Beamable SDK Matchmaking feature allows player to join a matchmaking queue (defined by a <code>UBeamGameTypeContent</code> instance), configure rules for matches to be made, receive notifications of progress and, optionally, provision a Game Server with a 3rd Party Game Server Orchestrator for the resulting match. </p>"},{"location":"user-reference/beamable-services/matchmaking/#ubeamgametypecontent-as-queues","title":"<code>UBeamGameTypeContent</code> as Queues","text":"<p>Beamable's Matchmaking system depends on Beamable's Content System in order for you to define various matchmaking queues.</p> <p>Each Matchmaking queue is described by a <code>UBeamGameTypeContent</code>. This content type defines a few things about a queue:</p> <ul> <li><code>TArray&lt;FBeamMatchmakingTeamRules&gt; Teams</code>: Defines the number of teams (one per entry in the array) and, for each of those teams, defines the number of players and a name.</li> </ul> <p>Dynamic Team Sizes</p> <p>This is for fixed-team-size queues. For teams that are built after the match is made, you can use the resulting Lobby's data and Federated Game Servers to compute and store the dynamic team split.</p> <ul> <li><code>FOptionalBeamStatComparisonRule EntryRules</code>: Optionally defines a set of Stat comparison rules. Only players whose Stats match those comparisons will be allowed into this queue.</li> </ul> <p>Gating on Rank</p> <p>Failing to meet entry rule requirements will cause the Join Operation to fail --- so these can be used to gate queues on a player's account level or rank for example.</p> <ul> <li><code>Numeric Rules</code> and <code>String Rules</code>: These are match grouping rules.<ul> <li>Numeric Rules tries to group players with a particular stat within certain delta range.</li> <li>String Rules groups players whose values for a particular stat match a certain value.</li> </ul> </li> </ul> <p>Grouping by WinRate</p> <p>If you compute and store an Win Percentage value in a <code>Stat</code>, for example, you can tell the queue to group players that are closer in win-rate than others using Numeric Rules.</p> <ul> <li><code>MaxWaitDurationSecs</code>: Defines how long the player can stay in the queue without being matched; after this time passes, the matchmaking fails and <code>OnMatchTimedOut</code> is triggered.</li> <li><code>MatchingIntervalSecs</code>: Defines the ticking interval for the queue. Defaults to 10 seconds, which means that new sets of matches are produced every 10 seconds.<ul> <li>If the time it takes to tick a queue is longer than the value set here, the longer value becomes the new tick.</li> </ul> </li> <li><code>FederatedGameServerNamespace</code>: Defines a Federation Id for a Federated Game Server federation.</li> </ul>"},{"location":"user-reference/beamable-services/matchmaking/#joiningleaving-queues","title":"Joining/Leaving Queues","text":"<p>The Matchmaking Subsystem the SDK provides out of the box provides you a few things:</p> <ul> <li>A \"Join a Queue\" Operation.</li> <li>A \"Leave a Queue\" Operation.</li> <li>A \"I'm in the queue, but wasn't matched yet\" callback (<code>OnMatchSearching</code>)</li> <li>A \"I was in the queue for too long without a match\" callback (<code>OnMatchTimedOut</code>)</li> <li>A \"I got matched and my match is ready\" callback (<code>OnMatchReady</code>)</li> <li>A \"I left the queue before getting matched\" callback (<code>OnMatchCancelled</code>)</li> </ul> <p>Party System</p> <p>Beamable's backend supports party matchmaking. The <code>OnMatchRemoteSearchStarted</code> and <code>OnMatchCancelled</code> are how a party member who is not the leader becomes aware that the leader has joined/left a queue for their party.</p> <p>The SDK does not have nice ergonomics for using this yet, but it is possible to use our Party system writing your own operations on top of <code>UBeamPartyApi</code>.</p> <p>Each player can only be in a single queue at a time. When joining a queue, you can optionally pass in a set of key/value pairs called <code>FBeamTag</code>. When a match gets made with that particular user/party, these tags end up inside the Lobby's per-player data. If you're in a party, the party leader is the only one allowed to join a queue on behalf of the party.</p> <p>Party and Tags</p> <p>When joining a queue as the party leader and passing in <code>FBeamTag</code>, those tags are only for the party leader. If you need to gather data for every user, we recommend using Federated Game Server and Stats to get that data into the Lobby instead.</p> <p>Leaving a queue is very straight-forward; just call the function with the appropriate <code>FUserSlot</code> and at the end of the Operation the \"matchmaking ticket\" will be invalidated and you'll no longer be in the queue. When using this, keep in mind that the ticket is only invalidated after the operation completes; not after this function is called.</p>"},{"location":"user-reference/beamable-services/matchmaking/#match-found-and-tickets","title":"Match Found and Tickets","text":"<p>When you join a queue in Beamable's matchmaking, you get back a <code>FBeamMatchmakingTicket</code>. This ticket contains information about the entry onto the queue:</p> <ul> <li>GameType is the queue type.</li> <li>GamerTagsInTicket hold the list of players that are in the ticket.</li> <li>SlotsInTicket hold the list of local <code>FUserSlot</code> that are in the ticket (just the Owner Player, unless your game has multiple local players and matchmaking).</li> <li>FoundMatchLobbyId is only filled inside the <code>OnMatchReady</code> callback and has the id for the resulting Lobby for the match. You can use this to retrieve data from the Lobby Subsystem inside the <code>OnMatchReady</code> callback to get connection information and more.</li> </ul> <p>If you want to understand a bit more about these tickets, we recommend taking a look at the source code of the <code>UBeamMatchmakingSubsystem</code> (it is pretty simple and should give you a lot more confidence in understanding the system).</p>"},{"location":"user-reference/beamable-services/matchmaking/#getting-started","title":"Getting Started","text":"<p>To use <code>UBeamMatchmakingSubsystem</code> via blueprints (or C++), you'll need to:</p> <ul> <li>Use the Content Window to create a <code>game_type</code> content with a single team with a Min/Max player count of 1.</li> <li>Publish that content to your realm.</li> <li>Assign delegates to <code>OnMatchReady</code>, <code>OnMatchCancelled</code>, <code>OnMatchTimedOut</code>, so on...</li> <li>Call <code>TryJoinQueueOperation</code> with the signed in <code>FUserSlot</code> and the created <code>game_type</code> content.</li> <li>After a short duration, you should see the <code>OnMatchReady</code> callback being triggered with a lobby containing just you as a player.</li> <li>That is it!</li> </ul> <p>Loggin in</p> <p>Make sure that user is logged in when the code above runs. See our Identity documentation</p>"},{"location":"user-reference/beamable-services/stats/","title":"Stats","text":""},{"location":"user-reference/beamable-services/stats/#overview","title":"Overview","text":"<p>The Beamable SDK Stats feature allows player to track a variety of built-in and custom player stat variables with configurable visibility levels. Two main use cases are:</p> <ul> <li>Data Store- can hold key/value pairs associated with a particular user.</li> <li>Targeting-  These key/value pairs can be used by other Beamable systems for various things (Announcement Campaings, Matchmaking and others).</li> </ul>"},{"location":"user-reference/beamable-services/stats/#types-of-stats","title":"Types of stats","text":"<p>There are two important specifiers of each stat.</p> <p>First one is <code>visibility</code>, in Unreal represented by enum <code>EBeamStatsVisibility</code>, it describes who can see stat:</p> <ul> <li><code>private</code>- Visible only to owning User and Backend.</li> <li><code>public</code>- Visible to any User.</li> </ul> <p>Second one is stat <code>domain</code>, in Unreal represented by enum <code>EBeamStatsDomain</code>, it describes if stat can be retrieved from game itself or does it require using microservices:</p> <ul> <li><code>client</code>- Can be accessed from both the Unreal and Microservices.</li> <li><code>game</code>- Cannot be accessed from Unreal directly, it can still be accessed via Microservice using <code>ClientCallable</code> calls.</li> </ul>"},{"location":"user-reference/beamable-services/stats/#getting-started","title":"Getting Started","text":"<p>In order to create write to a player stat from the client via Blueprints we will use <code>BeamStatsSubsystem</code>.</p> Logging in <p>Make sure that user is logged in when the code below runs. See Identity</p> <ul> <li>Call <code>Try Create Update Command</code> with a set of key-value pairs that are your stat values.</li> <li>Optionally call <code>AddStatToUpdateCommand</code> and <code>RemoveStatFromUpdateCommand</code>.</li> <li>After that,  use the <code>Commit Stats Operation</code> node to commit the new stats to Beamable.</li> <li>That is it!</li> </ul> <p></p> <p>To verify it worked, you can:</p> <ul> <li>Set aside the <code>Gamertag/UserId</code> from the Unreal Engine logs.</li> <li>Click <code>Open Portal</code> in Beamable window.</li> <li>Go to <code>Engage-&gt;Players</code> and search for the player via <code>Gamertag/UserId</code>.</li> <li>Go to <code>Stats</code> and search for <code>NewStatKey</code>.</li> <li>You should see that it exists with correct value.</li> </ul> <p></p>"},{"location":"user-reference/beamable-services/stats/#usage-guidelines","title":"Usage Guidelines","text":""},{"location":"user-reference/beamable-services/stats/#batching-updates","title":"Batching updates","text":"<p>In this example there is created a new <code>UpdateCommand</code> and committed right away. For better performance and reduced calls to Beamable, it is encouraged to:</p> <ul> <li>Create <code>UpdateCommand</code></li> <li>Use the other functions in the <code>UBeamStatsSubsystem</code> to set up as many changes as possible.</li> <li>Commit.</li> </ul> <p>When it is possible (and desirable) for your game, this flow reduces the overall latency your players experience and reduces the number of API calls you make to Beamable.</p>"},{"location":"user-reference/beamable-services/stats/#stats-keys-values","title":"Stats Keys &amp; Values","text":"<p>We do not enforce limitations on stat-keys or values. However, we do highly recommend the following guidelines for project organization and performance reasons.</p> <ul> <li>For Keys:<ul> <li>8-20 characters are ideal (purely for human ergonomics).</li> <li>Keeping them under a few hundred characters is best for performance.</li> <li>Use enforce-able and recognizable patterns for your keys.<ul> <li>Bad: <code>CharacterTalents</code> and <code>LoadoutForCharacter</code></li> <li>Good: <code>CHAR_Talents</code> and <code>CHAR_Loadout</code></li> </ul> </li> <li>Keeping your project organized is key (no pun intended).</li> </ul> </li> <li>For Values:<ul> <li>Values should be no more than a few hundred characters long.</li> <li>If you need larger complex data structures, we recommend you use Storage Objects instead.</li> </ul> </li> </ul> <p>In our DB, we index on keys for faster reading; the bigger the key sizes, the larger the index grows. Keeping the index smaller, leads to better performance in both reading and writing.</p>"},{"location":"user-reference/beamable-services/stores/","title":"Stores","text":""},{"location":"user-reference/beamable-services/stores/#overview","title":"Overview","text":"<p>Beamable's Store feature enables game-makers to create an in-game storefront where users can purchase items using virtual currency.</p> <p>Purchases IAP support</p> <p>Beamable supports purchasing listings using in-game IAPs, but for the Unreal SDK, this feature is not yet available. It will be added in future releases.</p>"},{"location":"user-reference/beamable-services/stores/#content-types","title":"Content Types","text":"<p>In Unreal, Stores are represented by <code>UBeamStoreContent</code> class, which includes a store title and a list of links to <code>UBeamListingContent</code> types. The <code>UBeamListingContent</code> class contains all the details about the offer, such as player requirements, costs, and benefits. Make sure you understand the Content System as both <code>UBeamStoreContent</code> and <code>UBeamListingContent</code> are subclasses of <code>UBeamContentObject</code>.</p>"},{"location":"user-reference/beamable-services/stores/#store-content","title":"Store Content","text":"<p>The store content has the following properties: - Show Innactive Listing: Shows things that the user already bought and their outside of availability window or outside cohort settings. - ActiveListingLimit: Defaults to 20. The Store will only show the first N listings that are valid. When asking for all active listings for a particular user, the API will return a maximum of whatever is here.</p>"},{"location":"user-reference/beamable-services/stores/#listing-content","title":"Listing Content","text":"<ul> <li>Price: Is the definition of <code>currency</code> a player must have to acquire this listing.</li> <li>Offer: Describes what will be added to the player's inventory.</li> <li>Client Data: Use this to store information specific to your game's UI in a way that you can parse and display.</li> <li>DateTime: Is an active period is an ISO-8601 string.</li> <li>Purchase Limit: Number of times the listing is purchasable by the same user. Since its optional, absent means infinite purchases allowed while the listing other filters say you can buy it.</li> </ul>"},{"location":"user-reference/beamable-services/stores/#beam-store-subsystem","title":"Beam Store Subsystem","text":"<p>Purchases are handled through the <code>UBeamStoreSubsystem</code>. This subsystem allows you to request the purchase of any available <code>Listing</code> on any <code>Store</code>. It also provides helper functions to retrieve detailed data from listings, making it easier to interact with store content.</p> <p>You can fetch a particular player's view of a particular store, via the <code>RefreshStoresOperation</code> or <code>RefreshStoreOperation</code>. After the view is refreshed, you can access the view for that particular player through <code>TryGetStoreView</code>. To make purchases, you can use the <code>PerformPurchaseOperation</code>.</p>"},{"location":"user-reference/federation/federated-game-server/","title":"Federated Game Server","text":"<p>Game Server Federation allows you to integrate with 3rd Party Game Server Orchestrator (such as Hathora or Agones) as well as running arbitrary server-authoritative code before a lobby goes into a match.</p> <p>The interface you implement looks like this:</p> <pre><code>public async Promise&lt;ServerInfo&gt; CreateGameServer(Lobby lobby);\n</code></pre> <p>There are two Federation Calls to this function: Matchmaking Match Found and Provision Game Server for Lobby.</p>"},{"location":"user-reference/federation/federated-game-server/#matchmaking-match-found","title":"Matchmaking Match Found","text":"<p>This is an Out-of-Band call that happens as part of the Matchmaking flow:</p> <ol> <li>Add the <code>IFederatedGameServer</code> federation to your microservice with a particular Federated Id.</li> <li>Set up that Federated Id in any <code>UBeamGameTypeContent</code>'s <code>federation</code> field.</li> <li>Use the <code>UBeamMatchmakingSubsystem</code>'s <code>TryJoinQueue</code> operation passing along that <code>UBeamGameTypeContent</code>'s id to join the queue.</li> <li>Once a match is made, the <code>CreateGameServer</code> federated function will be invoked with a Lobby structure containing all of the players matched together.</li> <li>This function can then do one or more of the following things:<ol> <li>Use a 3rd Party API to provision a game server, wait for it to spin up and add the connection information to the <code>ServerInfo</code> return object.</li> <li>Pre-fetch data associated from each player from Stats, Inventory or Storage Objects and add that data into the <code>ServerInfo</code> return object.</li> </ol> </li> <li>The returned <code>ServerInfo</code> object gets merged into the Lobby's global and player data.<ol> <li>In your game server build, the Lobby can be automatically prefetched if configured correctly, check more about it here.</li> </ol> </li> <li>The client SDK receives a notification from Beamable that a match is ready and invoke the <code>UBeamMatchmakingSubsystem</code>'s <code>OnMatchReady</code> callback for the match ticket.</li> </ol> <p>You can check out our Hathora Demo for more information on how to implement the actual <code>CreateGameServer</code> function.</p>"},{"location":"user-reference/federation/federated-game-server/#working-locally","title":"Working Locally","text":"<p>Because this is an Out-of-Band call, you'll need to set a content-id filter for which queues you want your locally running microservice to handle when its running.</p> <p>You can do this via the Federation tab of the Microservice window or by using the following commands: <pre><code># Gets the current content filter for the this Service, FederationType and Federation Id.\ndotnet beam federation local-settings get IFederatedGameServer --beamo-id MyService --fed-id myid\n\n# Sets the content ids filter for the IFederatedGameServer\ndotnet beam federation local-settings set IFederatedGameServer --beamo-id HathoraDemo --fed-id hathora --content-ids game_types.my_queue\n</code></pre></p>"},{"location":"user-reference/federation/federated-game-server/#provision-game-server-for-lobby","title":"Provision Game Server for Lobby","text":"<p>Certain games allow players to create custom lobbies manually. If those games also require invoking the federation endpoint to provision a server or run some arbitrary code, they can do so via the following steps:</p> <ol> <li>Add the <code>IFederatedGameServer</code> federation to your microservice with a particular Federated Id.</li> <li>Set up that Federated Id in any <code>UBeamGameTypeContent</code>'s <code>federation</code> field.</li> <li>Create a Lobby with the <code>UBeamGameTypeContent</code>'s id.<ol> <li>Closed/Open lobbies both work with federation.</li> </ol> </li> <li>Players will join the lobby and eventually become ready.<ol> <li>Most custom lobby implementations use <code>UBeamLobbySubsystem</code>'s <code>UpdatePlayerTags</code> function to update each individual player's ready state.</li> </ol> </li> <li>Once all players are ready, the lobby host can invoke the <code>UBeamLobbySubsystem</code>'s <code>ProvisionGameServerForLobby</code> function.</li> <li>This function requests that  the configured federation on the <code>UBeamGameTypeContent</code>'s <code>CreateGameServer</code> implementation.This function can then do one or more of the following things:<ol> <li>Use a 3rd Party API to provision a game server, wait for it to spin up and add the connection information to the <code>ServerInfo</code> return object.</li> <li>Pre-fetch data associated from each player from Stats, Inventory or Micro Storages and add that data into the <code>ServerInfo</code> return object.</li> </ol> </li> <li>Once that function returns, it'll trigger <code>UBeamLobbyState</code>'s <code>OnLobbyUpdated</code> callback for the lobby each particular player is in.<ol> <li>You can check if the connection information you generated inside <code>CreateGameServer</code> is within the lobby's global properties (<code>ULobby::Data</code>) and use that to connect all players to the newly created game server instance.</li> </ol> </li> </ol> <p>While we don't have a sample showcasing this exact case, you can still learn a lot about this from our Hathora Demo sample.</p>"},{"location":"user-reference/federation/federated-inventory/","title":"Federated Inventory","text":"<p>Federated Inventory allows you to integrate with other 3rd Party inventory systems such as Steam's Inventory or Web3 wallets. Because of this intended usage, all <code>FederatedInventory</code> implementations are also Federated Login implementations.</p> <p>Here's how this works at a high-level:</p> <ul> <li>Take a <code>UBeamItemContent</code> or <code>UBeamCurrencyContent</code> whose <code>federation</code> field has a valid Federation Id.</li> <li>Whenever a the inventory is fetched, if that content object is within its scope, the Beamable backend will invoke the <code>GetInventoryState</code> call with the user's 3rd Party  <code>UserId</code> as its parameter.</li> <li>Whenever an inventory update is committed, any currencies or items involved that are federated are bundled up and passed into <code>StartInventoryTransaction</code>.</li> </ul> <p>Here's some more detail:</p> <pre><code>// The \"id\" parameter is the UserId that the IFederatedLogin.Authenticate generates\n// All this function really does is add instances of items and currencies to the \n// response and forward it along.\nPromise&lt;FederatedInventoryProxyState&gt; GetInventoryState(string id);  \n\n// The \"id\" parameter is the UserId that the IFederatedLogin.Authenticate generates\n//\n// The \"transaction\" parameter is an optional string provided by the caller.\n// You are expected to provide an idempotency guarantee that every given \n// transaction string value is only processed once.\n// In most cases, this is just a passalong to Web3 wallet or wherever you're \n// keeping the inventory information. If that's not supported by your 3rd Party, \n// you can leverage StorageObjects to provide this guarantee.\nPromise&lt;FederatedInventoryProxyState&gt; StartInventoryTransaction(  \n    string id,  \n    string transaction,  \n    Dictionary&lt;string, long&gt; currencies,  \n    List&lt;FederatedItemCreateRequest&gt; newItems,  \n    List&lt;FederatedItemDeleteRequest&gt; deleteItems,  \n    List&lt;FederatedItemUpdateRequest&gt; updateItems);\n</code></pre> <p>Support in SDK</p> <p>Support for this federation in the SDK's <code>UBeamInventorySubsystem</code> is coming soon.</p>"},{"location":"user-reference/federation/federated-login/","title":"Federated Login","text":"<p>Login Federation is Beamable's approach to integrating 3rd Party Authentication with various platforms. You can find working examples of this federation in both Steam and Discord Samples.</p> <p>This Federation is always invoked In-Band and via the <code>Login_____</code>,  <code>SignUp____</code> and <code>Attach____</code> functions of the <code>UBeamRuntime</code> subsystem class.</p> <p>Its interface has a single function called Authenticate with the following signature:</p> <pre><code>public async Promise&lt;FederatedAuthenticationResponse&gt; Authenticate(string token, string challenge, string solution);\n</code></pre> <p>2FA</p> <p>You can implement 2FA with this. That's the purpose of the <code>challenge</code> and <code>solution</code> parameters. However, the UE SDK doesn't officially support this yet.</p> <p>The purpose of this function is:</p> <p>Map a 3rd Party token to a Unique Identifier for the user within the 3rd Party.</p> <p>Most of the time, you achieve this by doing the following:</p> <ol> <li>[Game Client]: Use the 3rd Party Client SDK to get a token of sorts.<ol> <li>See our Steam and Discord Samples for examples of this.</li> </ol> </li> <li>[Game Client]: Invoke a <code>Login</code>/<code>SignUp</code>/<code>Attach</code> Operation and pass the following parameters:<ol> <li>MicroserviceName: this is the name of the Microservice (the csproj file name, in the default case).</li> <li>IdentityNamespace: this is the Federation's Federation Id. Passing this in informs Beamable which federated login to invoke as part of the account creation/attach flow.</li> <li>IdentityUserId: this is the 3rd Party's <code>UserId</code> for the user trying to login. We use this to determine if there's already a Beamable account mapped to this 3rd Party Id.</li> <li>IdentityAuthToken: this is a token that for the user that can be used by the <code>Authenticate</code> function to map it back to a <code>UserId</code>.</li> </ol> </li> </ol> <p>After this, the flow goes into your <code>Authenticate</code> function. What that function should do, depends on whether or not you are implementing 2FA or not.</p>"},{"location":"user-reference/federation/federated-login/#federated-login-without-2fa","title":"Federated Login - without 2FA","text":"<p>Semantically, there are two ways the <code>Authenticate</code> function can be called:</p> <ul> <li>Account Creation Time: When using <code>UBeamRuntime</code>'s  <code>LoginExternalIdentity</code> or <code>SignUpExternalIdentity</code> Operations. </li> <li>Account Attach Time: When using <code>UBeamRuntime</code>'s  <code>AttachExternalIdentity</code> Operations. </li> </ul> <p>In both cases, what you want to do is:</p> <ol> <li>Use the 3rd Party's APIs or C# SDKs to validate the provided <code>token</code>.</li> <li>Use the 3rd Party's APIs or C# SDKs to get the <code>UserId</code> for that <code>token</code>'s user.</li> <li>Return <code>UserId</code> the <code>FederatedAuthenticationResponse</code> .</li> </ol> <p>The main different between both cases is that:</p> <ul> <li>Account Creation Time: <code>Context.UserId</code> is <code>0</code>; as at this time, no account exists.</li> <li>Account Attach Time: <code>Context.UserId</code> is a valid <code>GamerTag</code>; as you are adding an identity to an existing account.</li> </ul> <p>For non, 2FA flows (which are most of the Store and Console login flows) this is all that is needed.</p>"},{"location":"user-reference/federation/federated-login/#federated-login-2fa","title":"Federated Login - 2FA","text":"<p>Semantically, there are an additional two ways that the Authenticate function can be called:</p> <ul> <li>Without a <code>challenge</code>/<code>solution</code>: This is the first part of the flow. <ul> <li>Here, your function should generate a <code>challenge</code> and return it in the <code>FederatedAuthenticationResponse</code>.</li> <li>The <code>UserId</code> in <code>FederatedAuthenticatedResponse</code> should be empty in this first step.</li> <li>3rd Party SDK's that support/require 2FA will typically provide you a function to generate said challenge.</li> <li>The <code>challenge</code> is sent back to the client who should then solve it.</li> <li>After solving the challenge, the client must invoke <code>Login</code>/<code>Attach</code> again, but now passing in the <code>challenge</code> and <code>solution</code>.</li> </ul> </li> <li>With a <code>challenge</code>/<code>solution</code>: This is the second part of the flow.<ul> <li>If the <code>solution</code> is not empty, the <code>Authenticate</code> function should validate it against the <code>challenge</code>.</li> <li>If successful, the function should then return a valid <code>UserId</code> in <code>FederatedAuthenticationResponse</code>.</li> </ul> </li> </ul> <p>UE SDK Support</p> <p>This flow's usability in the engine SDK is not particularly good right now. You can achieve this by writing your own implementation of <code>Login</code>/<code>Attach</code> that maps better to 2FA than the existing ones.</p> <p>This is a high priority issue for us and better 2FA support should be done in the next minor release.</p>"},{"location":"user-reference/federation/federation/","title":"Federation","text":"<p>Federations are similar to the idea Server Side Callbacks or WebHooks but are slightly expanded in use. It is Beamable's approach to solving extending, or some times delegating, the behavior of our Managed Services to microservices or 3rd parties.</p> <p>Here are a few example use-cases that Federations as a concept means to solve:</p> <ul> <li>Implementing 3rd Party Auth Integrations with other Identity Providers</li> <li>Customizing Initial Player Account States</li> <li>Integrating Beamable Inventory with Steam Inventory or Web3 Wallets.</li> <li>Integrating with Game Server Orchestrators such as Hathora, Agones or even a custom stack.</li> <li>Etc...</li> </ul> <p>Most implementations of Server-Side Callbacks are fire-and-forget (similar to a webhook). Federations, however, don't need to be fire-and-forget. Most Federations are calls made to your microservice happen as part of a particular flow, often having things happening before and/or after the Federated call finishes.</p> <p>Here's a high-level diagram of what federations are:</p> <p></p> <p>As such, each of the Federations we provide have their own semantics, usage guidelines, performance characteristics and constraints described in their individual pages.</p>"},{"location":"user-reference/federation/federation/#federation-calls","title":"Federation Calls","text":"<p>There are two types of Federations Calls our Backend makes:</p> <ul> <li>In-Band Federation Calls</li> <li>Out-of-Band Federation Calls</li> </ul> <p>In-Band Federations are any Federation call that is in the path of a request originating from a game's client or real-time game server. Examples of these are <code>IFederatedLogin</code>, <code>IFederatedInventory</code> or <code>IFederatedGameServer</code>(when called via the Lobby system's <code>ProvisionGameServer</code> from a client).</p> <p></p> <p>Out-of-Band Federations are any Federation calls that are triggered by some server event that originates from inside the Beamable's Managed Services. The most obvious example is <code>IFederatedGameServer</code> (when called for each match found as part of a matchmaking queue tick).</p> <p></p> <p>For more information about the workflow implications of the difference between both Federation Call types, see below.</p>"},{"location":"user-reference/federation/federation/#federation-id","title":"Federation Id","text":"<p>Federations can be thought of delegates called by our server in particular points of various flows. Federation Ids are a unique <code>string</code>-based identifier that uniquely identifies a particular implementation of a federation. </p> <p>The combination of the Federation Id and the Federation Type is comparable to a function name/pointer used to assigned to an Unreal delegate; in the sense that it is used by the Beamable backend to know which implementation of a federation in your microservice it should talk to, if any.</p> <p>Examples:</p> <ul> <li><code>IFederatedLogin</code> would have a different implementations for Steam and Epic auth integration.</li> <li>As such, <code>IFederatedLogin&lt;SteamId&gt;</code> and <code>IFederatedLogin&lt;EpicId&gt;</code> the two different interfaces you'll need to implement. </li> </ul> <p>In other words, an id is just a unique <code>string</code> that you pass along in specific places depending on the federation to choose between one or more federations if any should be used.</p>"},{"location":"user-reference/federation/federation/#addingremoving-federations","title":"Adding/Removing Federations","text":"<p>Federations can be added and removed from services using  <code>dotnet beam fed</code> command pallet of the CLI.</p> <p>In code, Federations are tied to interfaces implemented in your <code>Microservice</code> inherited class --- these federations and its ids are automatically validated by a C# Analyzer that will tell you if you've missing things.</p> <pre><code># Adds an IFederatedLogin implementation to the MyMicroservice service with the \"cool\" id.\ndotnet beam fed add MyMicroservice cool IFederatedLogin\n\n# Adds an IFederatedGameServer implementation to the MyMicroservice service with the \"hathora\" id.\ndotnet beam fed add MyMicroservice hathora IFederatedGameServer\n</code></pre> <pre><code>// FederationIds.cs\n[FederationId(\"cool\")]\npublic class CoolId : IFederationId;\n\n[FederationId(\"hathora\")]\npublic class HathoraId : IFederationId;\n\n// MyMicroservice.cool.cs\npublic partial class MyMicroservice : IFederatedLogin&lt;CoolId&gt; { }\n// MyMicroservice.hathora.cs\npublic partial class MyMicroservice : IFederatedGameServer&lt;HathoraId&gt; { }\n</code></pre> <p>After adding any federation, your IDE will likely complain that you are not implementing the functions of the interfaces above; most IDEs will then offer you the option of generating the function signatures for those interfaces. After that, all you have to do is write the code for it.</p> <p>Why do you need the <code>federations.json</code>?</p> <p>We needed a consistent source of truth that would allow us to create the in-editor UXs without needing the built DLL to find which interfaces your service implements (because this is very slow and we can't guarantee this file's existence and \"up-to-date-ness\" easily).</p> <p>This source of truth is the <code>federations.json</code> file the commands above manage for you. </p> <p>This approach also allows us to detect implementation errors and emit compile-time errors for invalid or incorrect usage of microservice functionality. So... it was a win-win situation.</p>"},{"location":"user-reference/federation/federation/#workflows-for-developing-federations","title":"Workflows for Developing Federations","text":"<p>Most federations are inside complex application paths. As such, you need a way to iterate on them locally, much like how you do with <code>Callables</code> (see Microservices). This is the reason we differentiate between In-Band calls to Federations and Out-of-Band calls to federations.</p> <p>For In-Band Calls that reach a federated endpoint, the selected Microservice Target defines which running microservice instance will handle the federated call. In other words, you don't have to think about them. These get the same semantics as <code>Callables</code> routing.</p> <p>Out-of-Band Calls however do not originate in the client or gameplay server so we can't access PIE's selected Microservice Target. In order to solve that problem, out-of-band calls use semantic filtering logic to \"steal\" traffic from the realm's service. </p> <p>What about PROD?!</p> <p>By default, production realm disallows any and all routing to microservices that are not the deployed ones. In other words, if you run a local microservice while in a Prod realm it CANNOT steal any traffic from the service that is deployed; be it in-band or out-of-band.</p> <p>In order to configure these filters, you can use the Local - Federations tab of your Microservice Inspector. The filters, when out-of-band calls can be made to a particular federated endpoint, are described in each federation's own pages (for an example, see here).</p> <p></p>"},{"location":"user-reference/microservices/microservices/","title":"Beamable Microservices","text":"<p>Beamable Microservices are Beamable's Cloud Code solution. It is a wrapper around a HTTP Server that makes the development process much simpler. These are written in C# and come with a set of development tools that are tightly integrated with the UE Editor and Beamable CLI.</p> <p>This page explains the high-to-low-level concepts of Microservices and to what end they can be used. Take a look here for a getting started guide.</p>"},{"location":"user-reference/microservices/microservices/#why-this-approach-to-cloud-code","title":"Why this approach to Cloud-Code?","text":"<p>A lot of cloud-code solutions sacrifice a lot of flexibility, cost-efficiency, performance or developer experience in exchange for simplifying the simple case. Our goal was to focus on helping you with the complex cases while keeping the simple case easy to work.</p> <p>We do so by this architecture:</p> <p></p> <p>The Microservice is:</p> <ul> <li>An easy-to-write server that provides a set of Game-Maker-defined APIs.</li> <li>Locally \"debug-able\" (really, just press Debug on Rider). Collaboratively too.</li> <li>Deployed as a Docker container that you can customize.</li> <li>Promotable between Realms via the Portal OR our CLI (CI/CD folks rejoice).</li> </ul> <p>Under the hood, microservices are a wrapper around a custom WebSocket protocol and Job Scheduler with set of layered APIs you can use to easily write the simple cases and peel back to write the complex cases.</p> <p>It solves or helps with all the listed items above and the amount of code you actually need to write to expose an Endpoint your game can call is:</p> <pre><code>[ClientCallable]  \npublic int Add(int a, int b)  \n{  \n    return a + b;  \n}\n</code></pre>"},{"location":"user-reference/microservices/microservices/#microservice-window","title":"Microservice Window","text":"<p>The Microservice Window enables developers to start/stop local services, to read local service logs while in PIE and to configure local server settings for the collaborative workflow and for federations.</p> <p></p> <p>The left side of the window provides you a list of all services in your project with a set of filters based on Service Groups. The right side is the Details Panel.</p> <p>Service Groups</p> <p>In very rare cases, a project may require a non-trivial amount of services/storages. For Beamable's own internal development this is true (as we have microservices for each sample).</p> <p>In cases like these, a line can be added to the <code>csproj</code> file of each service to assign them to groups. These can then be used by the CLI's <code>project</code> pallet as filters while also being used as a filter in this window. The line to be added to the <code>BeamableSettings</code> PropertyGroup : <code>&lt;BeamServiceGroup&gt;SomeGroupId&lt;/BeamServiceGroup&gt;</code> </p> <p>There are no restrictions on group names other than that <code>BEAMPROJ_</code> is a reserved prefix.</p>"},{"location":"user-reference/microservices/microservices/#the-details-panel","title":"The Details Panel","text":"<p>The Details panel provides a detailed view of the microservices and access to a few features:</p> <ul> <li>Start/Stop the service in your local machine.</li> <li>Display logs for the service running on your local machine.</li> <li>Open the Beamable Portal targeting your local service.</li> <li>Configure which Microservice Target the Play-in-Editor sessions will target.</li> <li>Configure Federation-specific settings.</li> </ul>"},{"location":"user-reference/microservices/microservices/#local-logs-tab","title":"Local - Logs Tab","text":"<p>As the name implies, you can explore the logs for any running Microservice. You can filter by Log Level, substring search and also clear stored logs.</p> <p></p>"},{"location":"user-reference/microservices/microservices/#microservice-coding","title":"Microservice Coding","text":"<p>Microservices inherit from the <code>Microservice</code> base class and are <code>partial</code> by default. Inside each Microservice class, you can annotate instance methods with the following attributes to various effects:</p> <ul> <li><code>Callable</code>: This is the equivalent of a public endpoint. Any non-authenticated caller is allowed to invoke this function via a request.</li> <li><code>ClientCallable</code>: This is equivalent to an authenticated request. Any authenticated user in the same realm as the microservice is able to run this.</li> <li><code>AdminOnlyCallable</code>: These are similar to <code>ClientCallables</code> but requires the user to have admin privileges. They are useful for making utility endpoints called by internal developer tools.</li> <li><code>ServerCallable</code>: This is equivalent to a trusted-server request. It requires authentication in the form of a Signed Request. Primarily, these are callable from your game's Dedicated Server builds.</li> <li><code>Federated Endpoints</code>: Federations generate routes implicitly and do not need any <code>Callable</code> attributes.</li> </ul> <p>Inside the method body, there are a few concepts that are relevant:</p> <ul> <li><code>Context</code>: This field of the Microservice class has information about the request.<ul> <li><code>Context.Cid</code> | <code>Context.Pid</code>: Contain the relevant realm information for the microservice.</li> <li><code>Context.UserId</code>: Contains the <code>GamerTag</code> for the account making the call. This is <code>0</code> for non-authenticated endpoints such as <code>Callables</code> and <code>ServerCallables</code>.</li> <li><code>Context.Body</code>: Contains the raw body (typically JSON) of the request, if any.</li> </ul> </li> <li><code>Services</code>: This field of the Microservice class gives you access to Beamable's Services from your microservice.<ul> <li><code>Services.Inventory</code>: Access the inventory service...</li> <li><code>Services.Stats</code>: Access the stats service...</li> <li>So on and so forth...</li> </ul> </li> </ul> <p>Logging and Microservices</p> <p>We provide ways of dynamically changing the current log-level for deployed services. Finally, <code>BeamableLogger</code> is the correct way to log things from within your Microservice code.</p> <p>For more information on how to write microservice functions, you can take a look at our these docs as well.</p>"},{"location":"user-reference/microservices/microservices/#constraints-on-callable-functions","title":"Constraints on Callable Functions","text":"<p>Our CLI is capable of generating Unreal bindings that will allow your Unreal code to call your microservice much like you would make an API call to Beamable. In order to generate these bindings, we have some restrictions on what types can and can't be on method signatures for <code>Callables</code>. </p> <p>Each <code>Callable</code> generates at least two <code>UObject</code> classes, one representing request's input parameters and another representing the response type. It also generates a function inside the generated <code>UBeamMicroserviceNameApi</code> subsystem (and accompanying Blueprint nodes). </p>"},{"location":"user-reference/microservices/microservices/#signature-constraints","title":"Signature Constraints","text":"<p>When declaring <code>Callable</code> functions, you should be aware of a few limitations regarding its signatures.</p> <ul> <li>No <code>void</code> return.</li> <li>Can be <code>async</code> or not.</li> <li>Cannot return container types directly.<ul> <li><code>List&lt;&gt;</code> / <code>Dictionary&lt;string,&gt;</code> </li> <li>Wrap it in a struct/class instead.</li> </ul> </li> <li>No overloading of <code>Callables</code>.<ul> <li>This is because each of these must map to a unique route so name things accordingly.</li> <li>Non-<code>Callable</code> functions can be overloaded just fine.</li> </ul> </li> <li>Avoid calling <code>Callable</code> functions from other <code>Callable</code> functions.<ul> <li>For code-reuse in the Microservice, write non-<code>Callable</code> static functions and call them inside the <code>Callable</code> body. </li> </ul> </li> <li>Must be an instance methods (no <code>static</code> keyword).<ul> <li>Currently, every request is handled by a unique instance of the Microservice class.</li> <li>This also means that it is highly discouraged to put member fields in the the instance itself</li> </ul> </li> <li>If you are using Federations, you should be aware that each federation introduces certain reserved routes that you are then NOT allowed to use.</li> </ul> <p>Keep in mind that only a few things actually affect the shape of any particular <code>Callable</code>'s generated client code. This means that different signatures can effectively represent the same endpoint.</p> <p>The lists below all produce the same exposed API and generated client code:</p> <ul> <li>For primitive types:<ul> <li><code>public int PotatoAdd()</code></li> <li><code>public Promise&lt;int&gt; PotatoAdd()</code></li> <li><code>public Task&lt;int&gt; PotatoAdd()</code></li> <li><code>public async Promise&lt;int&gt; PotatoAdd()</code></li> <li><code>public async Task&lt;int&gt; PotatoAdd()</code></li> </ul> </li> <li>For complex types:<ul> <li><code>public MyCustomType PotatoAdd()</code></li> <li><code>public Promise&lt;MyCustomType&gt; MyCustomFunction(int arg1)</code></li> <li><code>public Task&lt;MyCustomType&gt; MyCustomFunction(int arg1)</code></li> <li><code>public async Promise&lt;MyCustomType&gt; MyCustomFunction(int arg1)</code></li> <li><code>public async Task&lt;MyCustomType&gt; MyCustomFunction(int arg1)</code></li> </ul> </li> </ul>"},{"location":"user-reference/microservices/microservices/#type-constraints","title":"Type Constraints","text":"<p>When you write types in C# and use them in <code>Callable</code> method signatures, you should keep in mind how these types map to the underlying UE <code>UObjects</code> and functions. The table below explains that mapping.</p> In UE In C# Microservices Notes Primitive Types <code>uint8</code> , <code>int32</code> , and <code>int64</code> <code>byte</code>, <code>int</code> and <code>long</code>. <code>float</code>  and <code>double</code> <code>float</code> and <code>double</code>. <code>bool</code> <code>bool</code> Unreal Types <code>FString</code> <code>string</code> <code>TArray&lt;&gt;</code> <code>List&lt;&gt;</code> or <code>T[]</code> Any <code>TArray&lt;SomeType&gt;</code> will serialize normally as long as <code>SomeType</code> also respects the constraints here. <code>TMap&lt;FString, &gt;</code> <code>Dictionary&lt;string,&gt;</code> We only support maps with <code>FString</code> as keys. The values can be any supported type. Beamable Types <code>FBeamArray</code> and <code>FBeamMap</code> Any nested container such as <code>List&lt;List&lt;&gt;&gt;</code> or <code>Dictionary&lt;string, List&lt;&gt;&gt;</code> These are used because nesting containers directly ( <code>TArray&lt;TArray&lt;&gt;&gt;</code> / <code>TMap&lt;,TMap&lt;&gt;&gt;</code>) breaks Blueprint Support. These get generated to maintain that support. A new UObject implementing <code>IBeamJsonSerializableUObject</code> Any C# Class Type The fields of the C# class must also adhere to the constrains on this table.If used in multiple <code>Callables</code> the generated type will be shared (our generate can identify that the same types is being used) <p>A few things to note:</p> <ul> <li>Unreal's lack of Namespaces in Blueprint-Compatible-land makes auto-generated code pretty verbose.<ul> <li>When using these APIs, we recommend liberal but careful use of <code>auto</code>.</li> </ul> </li> <li>The code for all microservices in the solution is generated at once. <ul> <li>This means that, if you have multiple Microservices, you cannot generate a single service's bindings. </li> <li>This is also a result of the Namespaces constraint.</li> </ul> </li> </ul> <p>Semantic Type Support</p> <p>In the future, we plan to support all <code>FBeamSemanticType</code> such as <code>FBeamGamerTag</code> and <code>FBeamContentId</code> as well as some Unreal-Specific types such as <code>FGameplayTag</code> and others.</p>"},{"location":"user-reference/microservices/microservices/#making-requests-on-behalf-of-users","title":"Making Requests on Behalf of Users","text":"<p>It is quite a common case that a Microservice needs to use one of our many APIs on behalf of a particular user. This allows you to re-use our APIs (that are usually written in a client-facing way) to be used for multiple users. A practical example:</p> <p>At the end of a MOBA match, you'll need to update player stats gathered during the match or process their account's new Experience or Rank. For this, you can make a <code>ServerCallable</code> called <code>ProcessMatchResults</code> and pass in information from your dedicated server whenever the match is over.</p> <p>In order to make requests on behalf of users we provide the <code>AssumeNewUser</code> function. It gives you back a <code>UserRequestDataHandler</code> that has fields like <code>Context</code> and <code>Services</code>. Making API calls from this <code>assumedUser.Services.Stats</code> instance as opposed to the usual <code>this.Services</code> will make the request on behalf of the user.</p>"},{"location":"user-reference/microservices/microservices/#multiple-microservices-and-organizing-code","title":"Multiple Microservices and Organizing Code","text":"<p>The first impulse a lot of people have is to separate microservices semantically; one-per-feature. We do not recommend this. Here's why:</p> <ul> <li>Having a lot of microservices will increase your cost for potentially no benefit.</li> <li>Having a lot of microservices increases project complexity.</li> <li>Having a lot of microservices makes you add latency to things that otherwise wouldn't have it (cross microservice communication is possible, but rarely actually needed).</li> <li>Having a lot of microservices increases deployment times.</li> </ul> <p>The key metric you should use to consider creating additional microservices is different load profiles at runtime. Basically, if you have a set of features with similar expected load profiles, you can keep them together as the auto-scaling will work uniformly to handle the increased load. If you have services with spikey load profiles (either in memory usage or CPU), then consider putting each of them in their own service so that they can be scaled independently and faster than your other larger services.</p> <p>Game Maker: \"If I have 5 features in one microservices, how do I organize my <code>Callable</code> functions?\"</p> <p>Beamable: \"You can create new parts of the <code>partial</code> Microservice type. You can declare utility static functions as well and make most <code>____Callable</code> just forward the call along.\"</p> <p>We've found these to be reasonable defaults that give you generally good runtime scalability for a low-cost and provide a simple developer experience. You should always keep an eye on your service's behavior for optimization opportunities as you observe its behavior under load.</p>"},{"location":"user-reference/microservices/microservices/#microservice-routing-and-microservice-target","title":"Microservice Routing and Microservice Target","text":"<p>When you make a request to a microservice, you're not actually directly talking to your service. Your request comes in via Beamable's Gateway service and that service figures out to which running Microservice instance it will forward that request.</p> <p>This allows us to integrate microservices running in your local machine \"as though they\" are part of the realm in two specific ways:</p> <ul> <li>Requests made from this editor's PIE instance can chose a Microservice Target.</li> <li>Out-of-band Federations can be configured with opt-in filters that \"steal\" traffic.</li> </ul> <p></p> <p>Enabling these two cases at the push of a button enables very fast development iteration speed.</p>"},{"location":"user-reference/microservices/microservices/#common-developer-workflows","title":"Common Developer Workflows","text":"<p>There are a few different ways to work with Microservices in Unreal, each with their own advantages and disadvantages. So, here we make our recommendations about them.</p> <p>These are NOT how-to guides, they are high-level descriptions to help you get a feel regarding how to work with Beamable and how its tools can be used to work alone and as a team.</p>"},{"location":"user-reference/microservices/microservices/#designing-the-api","title":"Designing the API","text":"<p>If you're in the very early stages of solving a problem and you just want to get the features to work, there's a workflow that doesn't require you to open Unreal at all, allowing you to focus only on getting your <code>Callables</code> to work!</p> <p>Here are the steps:</p> <ol> <li>Write your <code>Callable</code>'s code in your IDE.</li> <li>Press the Debug or Run button on the IDE.</li> <li>Wait for the Service to Start.<ol> <li>The service will print out <code>Service ready for traffic.</code></li> </ol> </li> <li>The service prints out a Portal URL for you.</li> <li>Access that.</li> <li>From that page, you can make requests to your service as though your own developer account was a player in your realm.</li> <li>Iterate quickly.</li> </ol> <p>This allows you to get services that might have complex logic working first and integrating them into Unreal later. Keep in mind the type restrictions on method signatures mentioned here.</p>"},{"location":"user-reference/microservices/microservices/#integrating-with-unreal","title":"Integrating with Unreal","text":"<p>Whenever it becomes preferable or necessary (see Federations) to test the microservice directly from Unreal's PIE mode, you can generate bindings for your <code>Callable</code> types and use them inside your game's code.</p> <p>Here you have two options:</p> <ul> <li>Run the <code>dotnet beam project generate-client Path/to/Service/built/dll</code> command manually to generate these bindings.<ul> <li>This command regenerates your client bindings AND run Unreal's <code>Regenerate Project Files</code> utility for you.</li> </ul> </li> <li>Add the line below to the <code>BeamableSettings</code> Property Group of your Microservice's <code>.csproj</code> file.<ul> <li><code>&lt;GenerateClientCode&gt;true&lt;/GenerateClientCode&gt;</code> </li> <li>This will run the above command automatically on every microservice rebuild (with changes).</li> </ul> </li> </ul> <p>We generate both C++ and Blueprint Bindings for every microservice <code>Callable</code>.</p> <p>IMPORTANT: Using the generated code in UE</p> <p>The generated code exist inside a <code>__________MicroserviceClients</code> plugin. So, you should add this plugin as a dependency to any project/plugin you have from which you want to make calls to your microservices (don't forget to add it to <code>Target.cs</code> files as needed). Also, call <code>________MicroserviceClients.AddMicroserviceClients(this)</code> on any of the <code>Build.cs</code> files you have and want to communicate with a microservice.</p> <p>Once you have these, you can:</p> <ol> <li>Write code that uses the bindings to communicate with your service.</li> <li>Recompile your UE editor (or Blueprint).</li> <li>Run/Debug your local microservice (via the Microservice Window, IDE or <code>dotnet beam project run</code>).</li> <li>Run PIE and hit the point where you call your microservice.</li> <li>See your local service's <code>Callable</code>'s be hit.</li> </ol> <p>If you are using Federations, there are a few particulars of this workflow of which you should be aware. If not, the above works as described.</p>"},{"location":"user-reference/microservices/microservices/#deploying-to-a-realm","title":"Deploying to a Realm","text":"<p>Once you have things working locally, you'll likely want to make the Microservice available to other team members working on the realm. If you just push your code up, other team members would also have to run the service locally and that might not always be desirable.</p> <p>As such, you should publish the services to the appropriate realm.</p> <p>Which realm?</p> <p>How you wish to manage realms is a team-specific decision as there are cost implications per-microservice instance running in any realm to consider against how your team likes to work.</p> <p>At Beamable's UE team, we prefer the \"team members are responsible not to break other team members environment\"-approach so we recommend that you test things thoroughly and then publish to your <code>dev</code> realm (where everybody is). </p> <p>Another strategy might be to have a <code>designer-dev</code> that lives between <code>staging</code> and <code>dev</code> that should be more stable and then you push to <code>dev</code> first and eventually promote it to <code>designer-dev</code>. Again, this is for your lead and team to discuss and decide how you wish to work.</p> <p>Finally, you can also choose a <code>one realm per developer</code> approach though that introduces a lot of workflow overhead. Though, there are team-specific cases where that might be a valid approach.</p> <p>The way to deploy services for our UE integration is 100% CLI-based. The documentation for it can be found here.</p> <p>Why no Deploy Editor UI?</p> <p>If there's enough demand for it, we will consider adding it. However, deploying services is mostly done by engineers and CI/CD pipelines so we felt that compiling and opening the UE Editor just to do this didn't add enough value to the UE workflow.</p>"},{"location":"user-reference/microservices/microservices/#collaborative-debugging","title":"Collaborative Debugging","text":"<p>This one is pretty unique to Beamable's Microservices. </p> <p>Imagine the following: </p> <ul> <li>You have a service published in a realm with your designer working and testing against it.</li> <li>The designer does something that reveals a bug in your service.</li> <li>It is unclear what causes it exactly and but the designer can repro it consistently by playing in PIE.</li> </ul> <p>Now, the usual flow for handling this situation would be similar to this:</p> <ul> <li>Make a ticket.</li> <li>Live with the bug while a ticket/task finds its way to an engineer, impacting designer productivity.</li> <li>Hope the engineer can repro it as consistently as the designer... or do it at all.</li> <li>Try to fix it in the future.</li> </ul> <p>Or... you could instead use Beamable's Collaborative Debugging workflow:</p> <ul> <li>As the engineer, hop on a voice chat with the designer and make sure you're in the same realm as them.</li> <li>As the engineer, boot up your local service with a debugger attached and a breakpoint.</li> <li>As the designer, open the editor and the Microservice Window's Collaboration tab for the service and select your engineer's email from the drop-down.</li> <li>As the designer, enter PIE and do what you do to repro the bug.</li> <li>As the engineer, observe your (conditional or data) breakpoint is hit or read your additional <code>BeamableLogger</code> log lines.</li> <li>Quickly diagnose the issue and unblock the designer.</li> </ul> <p></p> <p>For smaller teams that like to move fast and can rely on lots of direct communication between designers and engineers, this workflow is a massive improvement to the current available alternatives.</p>"},{"location":"user-reference/microservices/microservices/#micro-storages","title":"Micro Storages","text":"<p>Beamable Microservices allow you to store data in Beamable's own managed services such as <code>Stats</code>(Per-Player key-value stores) and <code>Inventory</code> (Per-Player fungible and non-fungible data tracking). However, there are cases where you want to control your own data-model and database. It might be necessary to hit your performance targets OR maybe it just makes your particular problem simpler to solve (instead of trying to fit it into our default stores).</p> <p>For those cases, Beamable offers a <code>MicroStorage</code>. This is a wrapper around a database that you can write to from your microservices. At the moment, we only support <code>MongoDB</code>. Like Microservices, these are scoped by realm as well (as in, data from Realm A is only visible in Realm A). Micro Storages.</p> <p>Relevancy for API Design and Client-Code Generation</p> <p>While there's no compilation problem in using types declared in the <code>MicroStorage</code> project as part of the signatures of <code>Callable</code> functions, we DO NOT RECOMMEND you expose these types in Callable functions.</p> <p>While it can be simpler and faster to prototype this way, the post-release implications of doing that are all very bad. It makes it harder to modify your internal schema and makes it harder to introduce new behavior without doing data-migrations.</p> <p>We recommend that <code>Callables</code> have unique request/response types for better long-term maintainability and flexibility.</p>"},{"location":"user-reference/microservices/microservices/#local-development-implications","title":"Local Development Implications","text":"<p>While you can develop microservices without Docker being run (except for its publishing step), you cannot do the same for <code>Microservices</code> that use <code>MicroStorages</code>. This is because the local running service expects there to be a locally running <code>MongoDB</code> instance it'll use as the Database.</p> <p>To make sure the above is true, we run <code>MongoDB</code>'s official container in your local Docker instance. This is managed automatically on startup of the microservice BUT does introduce a dependency on docker for local iterative development.</p>"},{"location":"user-reference/microservices/setting-microservices/","title":"Setting Up Microservices","text":""},{"location":"user-reference/microservices/setting-microservices/#getting-started-with-c-microservices","title":"Getting Started with C# Microservices","text":"<p>Creating your first microservice will automatically create your solution for you. Following the guide below will generate the following recommended folder structure:</p> <pre><code>/repo-root\n|- ProjectName.uproject\n|- ProjectName.sln\n|- ProjectNameBeamable/\n|-- ProjectNameBeamable.sln\n|-- services/\n|---- MicroserviceName/\n|------ MicroserviceName.csproj\n</code></pre> <p>Unreal and Version Control Systems</p> <p>Most Unreal <code>.[vcs]ignore</code> file templates you can find online ignore all <code>*.sln</code> files. Instead of doing that, make sure to only ignore in the root directory with this  <code>/*.sln</code> instead of <code>*.sln</code>.</p> <p>In Git, you can also ensure your Microservice <code>.sln</code> is not ignored explicitly via <code>!/ProjectNameBeamable/ProjectNameBeamable.sln</code>.</p>"},{"location":"user-reference/microservices/setting-microservices/#create-the-microservice-solution-and-project","title":"Create the Microservice Solution and Project","text":"<p>Make sure the editor is not running before starting this guide.</p> <p>Open a terminal/shell at your project's root and run the following command to create a new project and add a new microservice.</p> <pre><code>dotnet beam project new service MicroserviceName --sln ProjectNameBeamable/ProjectNameBeamable.sln\n</code></pre> <p>The created Microservice would look something like the example one below here.</p> <pre><code>[Microservice(\"MicroserviceName\")]\npublic partial class MicroserviceName : Microservice  \n{  \n    [ClientCallable]  \n    public int Add(int a, int b)  \n    {\n        return a + b;  \n    }\n}\n</code></pre> <p>Now that you have a microservice, you can compile it via your IDE.</p> <p>Afterwards, you can run the command below from your Game Project's root.</p> <pre><code>dotnet beam project add-unreal-project .\n</code></pre> <p>Linking a project informs our CLI where it should put generated C++ files for communicating with the Microservice from UE code. </p> <p>To generate the project files, run:</p> <pre><code># Run manually whenever you make schema changes to `Callable` method signatures (or types used in them)\ndotnet beam project generate-client ProjectNameBeamable/services/MicroserviceName/bin/path/to/built/dll\n</code></pre> <p>Automatic Code Generation &amp; Limitations</p> <p>You can also add <code>&lt;GenerateClientCode&gt;true&lt;/GenerateClientCode&gt;</code> to the <code>BeamableSettings</code> Property Group inside <code>MicroserviceName.csproj</code>; this will run the command on every re-build of the service DLL.</p> <p>The automatic code generation is in early experimental stages and might see breaking changes in the near-future. For this reason, it is currently disabled by default.</p> <p>After the generating the client in your Unreal project, these are the next steps:</p> <ul> <li>Add the generated plugin (<code>ProjectNameMicroserviceClients</code>) to your <code>uproject</code> file and enable it.</li> <li>Add the <code>ProjectNameMicroserviceClients</code> modules to your <code>Target.cs</code> files.</li> <li>Add <code>ProjectNameMicroserviceClients.AddMicroserviceClients(this)</code> line to your  <code>Build.cs</code> files.</li> </ul> <p>Now, you're ready to write code that invokes the microservice.</p> <p>Here's what that would look like:</p> <pre><code>// From inside any GameInstanceSubsystem, Actor or Component...\n\n// Get the Generated API subsystem\nconst auto MsApi = GEngine-&gt;GetEngineSubsystem&lt;UBeamMicroserviceNameApi&gt;();  \n\n// Create an instance of the generated Request object.\nconst auto Req = UMicroserviceNameAddRequest::Make(1, 2, GetTransientPackage(), {});  \n\n// Declare the handler for the addition\nconst auto Handler = FOnMicroserviceNameAddFullResponse::CreateLambda([this](FMicroserviceNameAddFullResponse Resp)  \n{  \n    // If the request failed or we are retrying, we do nothing  \n    if (Resp.State != RS_Success)  \n       return;  \n\n    // Otherwise, print the value \n    UE_LOG(LogTemp, Display, TEXT(\"Microservice Add: %d\"), Resp.SuccessData-&gt;Value);\n});  \n\n// Make the request (the user slot will usually be the UBeamCoreSettings::GetOwnerPlayerSlot())\nFBeamRequestContext Ctx;  \nMsApi-&gt;CPP_Add(UserSlot, Req, Handler, Ctx, {}, this);\n</code></pre> <p>Take a look at the Microservices docs for more information about where to go from here.</p>"},{"location":"user-reference/microservices/setting-microservices/#optional-create-a-microstorage","title":"Optional - Create a MicroStorage","text":"<p>MicroStorages are a Beamable feature that allows you, the Game-Maker, access to a MongoDB you can use to define your own custom persisted data formats to go along with your own custom microservice logic. </p> <p>This is a useful architectural alternative when making complex features that do not map well to the default cases of Beamable's own data-storing Managed Services (Stats, Inventory and CloudStorage).</p> <p>To create a <code>MicroStorage</code>, run the command below.</p> <pre><code>beam project new storage StorageName --sln ProjectNameBeamable/ProjectNameBeamable.sln \\\n  --link-to MicroserviceName\n</code></pre> <p>This will add a <code>StorageName.csproj</code> project to the solution and reference that new project in the <code>MicroserviceName.csproj</code> file, making the code in the <code>StorageName</code> project accessible to the Microservice.</p> <p>Storages cannot exist independent of Microservices and must be associated with one at all times. The <code>link-to</code> option will make the given Microservice depend on the newly created Storage. This dependency makes the storage accessible to the microservice.</p> <p>Running Locally</p> <p>MicroStorages require you to ALWAYS have docker running when running locally. Microservices that DO NOT DEPEND on storages can be run directly from the IDE without docker running at all. Microservices that DO DEPEND on storages can also be run from the IDE, but docker MUST be running too.</p> <p>Take a look at this documentation for more information on how to write the code inside Storages and how to access them in Microservices.</p>"},{"location":"user-reference/microservices/setting-microservices/#optional-libraries-and-c-microservices","title":"Optional - Libraries and C# Microservices","text":"<p>One of the big advantages of Beamable C# Microservices is that they are regular <code>.NET</code> projects. This means you get access to Nuget packages should you need to integrate Beamable with any particular Third-Party technology that we don't support out-of-the-box.</p> <p>To do so, use Nuget to add a package dependency to a project (this can be done easily through any IDE --- or through <code>dotnet nuget</code> command pallet).</p> <p>While definitely not the common case, it is possible for projects to require multiple services. When that happens, it is also common that those services share some logic or internal data types. To write your own code that is then shared between services:</p> <ul> <li>Create a <code>dll</code> project by running this command:<ul> <li><code>beam project new common-lib LibraryName --sln ProjectNameBeamable/ProjectNameBeamable.sln</code></li> </ul> </li> <li>Adding a reference to it in any of your Microservice's <code>.csproj</code> files by adding this line to an ItemGroup block: <ul> <li><code>&lt;ProjectReference Include=\"..\\LibraryName\\LibraryName.csproj\"/&gt;</code></li> </ul> </li> </ul> <p>UE Code Generation Limitations</p> <p>You can write any code here and share types between microservices. Keep in mind that, if you use these types in method signatures of multiple microservices, due to Unreal's lack of namespacing, you'll end up with two different UE types for the same shared type.</p> <p>For that reason, we currently recommend you do not expose shared complex types inside <code>Callable</code> method signatures.</p>"},{"location":"user-reference/online-subsystems/online-subsystem-identity/","title":"Identity Using Online Subsystm","text":"<p>There are several different styles of signup/login flows games might want to use. This section explores how to set them up.</p>"},{"location":"user-reference/online-subsystems/online-subsystem-identity/#frictionless-login-attaching-identities","title":"Frictionless Login + Attaching Identities","text":"<p>This flow is useful for when you want to automatically create a user for the player and then, some time in the future, you'll provide your player the opportunity to attach identities to them. Mostly used by mobile games, but can also be used to implement automatic Steam/Epic store logins.</p> <ul> <li>Use the <code>IOnlineIdentity::Login</code> function with a <code>LoginType</code> of <code>BeamOSS::GetIdentityTypeFrictionless()</code> to create an account (or sign into the locally cached one).</li> <li>Then, while signed into to an account, call <code>Login</code> again with a <code>LoginType</code> of <code>BeamOSS::GetIdentityTypeAttach____()</code> to attach a new identity to the currently logged in account.<ul> <li>Don't forget to reassign the callbacks on <code>OnLoginCompleteDelegates</code> before calling login to respond to success/failure of attaching.</li> </ul> </li> </ul> <p>Swapping Accounts when Attaching</p> <p>If you have <code>UOnlineSubsystemBeamableSettings::bAutoLoginOnAttach</code> set to <code>true</code>, trying to attach to an already-used identity will sign out of the current user and then sign-in to the given identity. Keep in mind the difference in the semantics of the <code>OnLoginCompleteDelegates</code> because of this.</p> <p>Ex: <code>User A</code> is signed into <code>Player0</code> and you try to attach an email belonging to <code>User B</code> to <code>Player0</code>. If <code>bAutoLoginOnAttach == true</code>, <code>User A</code> will be signed out of <code>Player0</code> and <code>User B</code> will be signed in and only then the <code>OnLoginCompleteDelegates</code> will trigger as a success.</p>"},{"location":"user-reference/online-subsystems/online-subsystem-identity/#manual-sign-uplogin-with-emailpassword","title":"Manual Sign-Up/Login with Email/Password","text":"<p>If your game has a sign-up and/or login screen that the user is expected to choose their sign-up or login flows, this is what you want.</p> <ul> <li>Use the <code>IOnlineIdentity::Login</code> function with a <code>LoginType</code> of <code>BeamOSS::GetIdentityTypeSignUpEmail()</code>.</li> <li>If you have <code>UOnlineSubsystemBeamableSettings::bAutoSignUpWhenLogin</code> set to <code>true</code>, you can use <code>BeamOSS::GetIdentityTypeEmail()</code> and it'll automatically create an account if the credentials provided aren't already associated with an account (if they are, you'll sign into the provided credentials).</li> </ul> <p>Attaching Other Identities</p> <p>You can still attach other identities using any of the <code>BeamOSS::GetIdentityTypeAttach____()</code>. The same rules around <code>bAutoLoginOnAttach</code> apply.</p>"},{"location":"user-reference/online-subsystems/online-subsystem-identity/#automatic-third-party-via-store-attaching-identities","title":"Automatic Third-Party via Store + Attaching Identities","text":"<p>If your game uses some third-party store identity such as Steam/Epic Store, you can follow this flow. This requires you to have correctly setup an identity federation for the store (see each federation's How-To guides for more information.</p> <ul> <li>Use the <code>IOnlineIdentity::Login</code> function with a <code>LoginType</code> of  <code>BeamOSS::GetIdentityTypeFederated()</code> with <code>UOnlineSubsystemBeamableSettings::bAutoSignUpWhenLogin</code> as <code>true</code>.<ul> <li>Each third-party identity may require different inputs. This depends on how your federation is set up. You can see our Discord and Steam samples for examples of how to write these federations.</li> </ul> </li> </ul> <p>Attaching Other Identities</p> <p>You can still attach other identities using any of the <code>BeamOSS::GetIdentityTypeAttach____()</code>. The same rules around <code>bAutoLoginOnAttach</code> apply.</p>"},{"location":"user-reference/online-subsystems/online-subsystem/","title":"Unreal Online Subsystems","text":"<p>Will Be Discontinued</p> <p>After a thorough evaluation conducted with our closest game-maker partners and their projects, we have decided to discontinue the <code>OnlineSubsystemBeamable</code> Plugin extension. </p> <p>Beamable has a lot of unique features that are very useful but become a lot harder to leverage if you're keeping it behind the OnlineSubsystem interface. In other words, supporting it is costly but doesn't generate as much value to our customers and partners as we originally thought it would. As such, we have decided to phase out support for it in favor of focusing our efforts in our <code>BeamableCore</code> plugin, docs, samples and a showcase project that will show how to leverage Beamable inside UE for a live-services game project.</p> <p>The discontinuing will come into effect at the last release this year but no more updates to it will happen to this documentation or the package from now until then.  </p> <p>To use our Online Subsystem integration to Unreal Online Subsystems, you'll need to update your <code>*.Target.cs</code> 's <code>Beam.ConfigureGame</code> method call. As well as re-running, <code>beam-init-game-maker.sh \"Path/To/SDK/Clone\" true</code> with a second argument as true.</p> <p>To enable the Enabling Online Subsystem would require updating the value of the second argument of that method, <code>Beam.OssConfig</code> value, example values for Hathora sample project:</p> <pre><code>var oss = new Beam.OssConfig()\n{\n    IsEnabled = true,\n\n    HooksEnabled = true,\n    HookSubsystemImplementation = \"FOnlineSubsystemHathoraDemo\",\n    HookSubsystemIncludePath = \"Customer/OnlineSubsystemHathoraDemo.h\",\n\n    AdditionalHookModules = new[] { \"HathoraSDK\" }\n};\n</code></pre>"},{"location":"user-reference/runtime-systems/connectivity/","title":"Connectivity Management","text":"<p>Games with live services require access to the internet and an open connection to the backend. In the Beamable SDK, an <code>FUserSlot</code> is considered connected:</p> <p>When there's a signed-in user and the WebSocket connection (see <code>UBeamNotifications</code> and <code>UBeamRuntime</code>) for that user is alive.</p> <p>The semantics above is also what our servers use to keep track of any user's presence (related to our <code>PresenceApi</code>).</p>"},{"location":"user-reference/runtime-systems/connectivity/#thinking-about-connectivity","title":"Thinking about Connectivity","text":"<p>The Beamable SDK provides a <code>UBeamConnectivityManager</code> class that keeps the connectivity state for any logged-in <code>FUserSlot</code>. For games that have only a single local player, you can use <code>UBeamRuntime::GetOwnerSlotConnectivity</code> to access the correct manager by default. For games with multiple local players, you can get the managers from <code>UBeamRuntime::GetSlotConnectivity</code> for each user (for the most part, they shouldn't differ in status though).</p> <p>After a user is logged-into a <code>FUserSlot</code>, losing the connection to the Beamable backend (due to internet access loss or otherwise), will have the <code>UBeamConnectivityManager</code> go into the <code>CONN_Offline</code> state. The details of this process are:</p> <ul> <li>The WebSocket connection fails.</li> <li>We attempt to reconnect X times before going into <code>CONN_Offline</code> to avoid jittery short-lived instability. (<code>Project Settings -&gt; Beam Runtime -&gt; ConnectivityRetryCountBeforeOffline</code>).<ul> <li>If all of these attempts fail, we go into <code>CONN_Offline</code>.</li> <li>If any of these attempts succeed, the game proceeds as normal without any callbacks being triggered.  </li> </ul> </li> </ul> <p>Once we go into <code>CONN_Offline</code>, two things happen:</p> <ul> <li>We trigger <code>UBeamConnectivityManager::OnConnectionLost</code> once (per-connection loss).<ul> <li>Provides simplicity for games that want to handle connectivity loss in fire-and-forget ways such as doing a game reset, displaying a blocking pop-up, etc... </li> </ul> </li> <li>We set up a Tick (<code>UBeamConnectivityManager::ReconnectionTick</code>) function to run while you are in <code>CONN_Offline</code> mode.<ul> <li>Provides more flexibility for games that want to handle connectivity loss in complex ways such as waiting for X amount of time before booting the player out, reducing available feature set, etc...</li> </ul> </li> </ul> <p>While in <code>CONN_Offline</code> mode, we'll keep trying to reestablish the <code>FUserSlot</code>'s connection with Beamable. This happens automatically in the background and is a continuous process. If we manage to reestablish the connection, one of two things will happen:</p> <ul> <li>If <code>Project Settings -&gt; Beam Runtime -&gt; AutomaticallyNotifyFixupComplete</code> is <code>true</code>:<ul> <li>We'll broadcast the <code>UBeamConnectivityManager::OnReconnected</code> delegate.</li> <li>We'll go back into <code>CONN_Online</code> mode.</li> </ul> </li> <li>If <code>Project Settings -&gt; Beam Runtime -&gt; AutomaticallyNotifyFixupComplete</code> is <code>false</code>:<ul> <li>We'll broadcast the <code>UBeamConnectivityManager::OnReconnected</code> delegate.</li> <li>We'll go into <code>CONN_Fixup</code> and set up the <code>UBeamConnectivityManager::FixupTick</code> function.<ul> <li>In this mode, you're expected to use the tick function to prepare your game to return to online mode. You could:<ul> <li>Wait until your game state would function if you were to refresh the <code>UBeamRuntimeSubsystem</code> implementations.</li> <li>Refresh the <code>UBeamRuntimeSubsystem</code> implementations.</li> <li>Call Microservices <code>ClientCallables</code></li> </ul> </li> <li>At this point, you are connected and everything will function just as though you were in <code>CONN_Online</code> mode.<ul> <li>This state exists to help your code guard against the case of \"I'm reconnected but not yet ready to function as though I'm online\".</li> </ul> </li> </ul> </li> <li>We'll wait until your game's code calls <code>UBeamConnectivityManager::NotifyFixupComplete()</code>.<ul> <li>Calling that puts you back into <code>CONN_Online</code> mode.</li> </ul> </li> </ul> </li> </ul> <p>The <code>UBeamRuntimeSubsystem</code> implementations DO NOT attempt to refresh their local state after automatically. This is an intentional design decision due to the following reasons:</p> <ul> <li>The <code>UBeamRuntimeSubsystem</code> implementations are stateful systems that expose delegates to which you, the game-maker, bind events and functions.</li> <li> <p>Connectivity can be lost and/or regained at any time in your game's flow. It can happen mid-cutscene, mid-gameplay, mid-pause menu, etc...</p> </li> <li> <p>If we automatically refreshed the subsystem's state after a reconnection, the callbacks throughout the refresh process would trigger.</p> </li> <li>This means that one of the things below would have to be true:<ul> <li>Upon going offline, we could unbind all callbacks (which is overeager and makes your binding code more complex) </li> <li>You have to write code for those delegates assuming it could run at any time (which is makes it a lot harder to write that code).</li> <li>You have to respond by any loss of connection by restarting the game (thus unbinding all delegates).</li> </ul> </li> <li>Our previous experience with automatic refreshing has been that it is just not worth it.<ul> <li>For every game-maker for whom our refreshing worked out of the box, it caused significant problems for another.</li> </ul> </li> </ul> <p>As such... we instead decided to automatically refresh and instead to give you the tools to correctly set up your game state as you need it to be.</p> <p>Why not do Request-based Heuristics?</p> <p>We have tried estimating internet connectivity via some amount of heuristics over failed requests. We have found that having a semantic for connectivity that results in more stability is better. Requests just timeout if you're not connected to the internet and try to make them (or make them and they can't reach the Beamable servers). Connectivity ONLY changes based on the WebSocket connection (which is \"stable-er\", at both the protocol level and at our own implementation level). This minimizes problems from broadcasting connectivity-related delegates in quick succession while making downstream code easier to write.</p>"},{"location":"user-reference/runtime-systems/lower-level/","title":"Lower-Level SDK Subsystems","text":"<p>This section talks about lower-level details of how requests to Beamable get made.  You don't need to read this, but... you might want to if you plan on implementing your own <code>UBeamRuntimeSubsystem</code>.  Here's why you'd want to do this:</p> <ul> <li>You want to replace one of our implementations with something custom and want to provide guarantees about your system's lifecycle that are similar to the ones we provide.</li> <li>You wish to guarantee that when <code>UBeamRuntime::OnUserReady</code> is triggered, you'll already have access to custom data fetched via Microservices and MicroStorages.</li> </ul> <p>We don't recommend writing your own unless you're confident you understand the topics below and are trying to solve one of the two problems listed above.</p> <p>Low Level Usage</p> <p>The systems described here are used by various environments the Beamable SDK runs in: PIE, Editor, Dedicated Server Builds and regular game builds.  Their code is pretty heavily commented; so, feel free to read it and figure things out that way.</p> <p>The lowest layer of systems are shared between the SDK's UE Editor integration and the SDK's Runtime integration:</p> <ul> <li> <p><code>UBeamUserSlots</code>: As explained at the start of this document, tracks multiple local signed-in users (for local co-op cases).</p> <ul> <li>Take a look at User Slots for more information about these.</li> </ul> </li> <li> <p><code>UBeamRequestTracker</code>: Provides BP-compatible async operations that emit various events as it goes along.</p> <ul> <li>You can think of these as \"BP-Compatible Promises\".</li> <li>These are integrated with our <code>UBeam____Api</code> subsystems.</li> <li><code>BeginOperation</code> is effectively the same a creating a new promise.</li> <li><code>TriggerOperationSuccess</code>, <code>TriggerOperationError</code> and <code>TriggerOperationCancelled</code> should be called when you want to complete the Operation.</li> <li>This is a somewhat complex subsystem so we recommend you read Operations and Waits</li> </ul> </li> <li> <p><code>UBeam_____Api</code>:  Code-Generated Subsystems from our Backend OpenAPI spec.</p> <ul> <li>These are stateless <code>UEngineSubsystem</code> implementations.</li> <li>These provide you low-level access to every end-point of our backend even if we don't have utilities in the SDK that do exactly what you want.</li> <li>As UE doesn't allow for namespaces AND BP-compatibility, this is verbose. We recommend more liberal use of <code>auto</code> when dealing with Code-Gen API Types.</li> <li>At runtime, don't forget to pass in any the <code>UObject* CallingContext</code> parameter: any <code>UWorld</code>, <code>UGameInstanceSubsystem</code>, <code>UActorComponent</code> or <code>AActor</code> will do.</li> </ul> </li> <li> <p><code>UBeamBackend</code>, <code>UBeamNotifications</code> and <code>UBeam_____Notifications</code> are discussed in the sections below.</p> </li> </ul>"},{"location":"user-reference/runtime-systems/lower-level/#ubeambackend","title":"<code>UBeamBackend</code>","text":"<p>This is the most important <code>UEngineSubsystem</code> in the SDK. It leverages Unreal's <code>HTTP</code> module to make requests to the configured Beamable backend. It contains the implementations used by the <code>UBeam____Api</code> classes to make the actual requests. </p> <p>These implementations handle:</p> <ul> <li>Request/Response serialization, deserialization and memory lifecycle.</li> <li>Configurable Retry Logic with per-request-type, per-user-slot and per-call-site granularity.</li> <li>Request's response Cache-ing, though this is disabled by default as caching is a very context dependent endeavor.</li> <li>Transparent and Automatic Re-Auth in case of expired <code>AccessToken</code> through a user's <code>RefreshToken</code>.</li> </ul> <p>We have a few different types of requests and 4 implementations to handle them:</p> <ul> <li>CPP and BP Authenticated Requests: require an <code>FUserSlot</code> with a logged-in user whose access token we'll use to make the request. </li> <li>CPP and BP Non-Authenticated Requests: does not require an <code>FUserSlot</code> with a logged-in user.</li> <li><code>UBeamBackend::CreateGenericBeamRequest</code>: for making requests to non-Beamable servers by <code>UBeamGenericApi</code>.</li> </ul> <p>In addition to these implementations, we also have a hierarchy of retry configurations.  You can configure these in <code>UBeamCoreSettings</code> (<code>Project Settings -&gt; Beamable Core</code>). Retries happen automatically on timeouts and a few other known cases. By default, these are:</p> <ul> <li>The <code>FBeamErrorResponse</code> structure received is a <code>408</code> status.<ul> <li>The Unreal HTTP Request returning a <code>EHttpFailureReason::ConnectionError</code> or <code>EHttpFailureReason::TimedOut</code> are parsed into <code>FBeamErrorResponse</code> with a <code>408</code>.</li> </ul> </li> <li>We got any errors defined in <code>UBeamBackend::AUTH_ERROR_CODE_RETRY_ALLOWED</code>.<ul> <li>These errors trigger out seamless authentication token refreshing flow. It'll refresh the token and then retry the request.</li> </ul> </li> </ul> <p>If you ever encounter issues with this system, <code>log LogBeamBackend Verbose</code> is a useful Unreal command that can be used as a diagnostic tool. It will print out the entire process of building the request, sending it out and receiving its response.</p> <p>Connectivity</p> <p>In the Beamable SDK, we do NOT handle the concept of \"player connectivity to the internet\" via request/response heuristics.  See <code>UBeamNotifications</code> below and Connectivity for more information.</p> <p>Request/Response Object Lifecycle</p> <p>When we deserialize every request's response, all its <code>UObject</code> instances are created with the Request <code>UObject</code> instance as its <code>Outer</code> parameter. We ensure that, as long as there are running Operations and Waits depending on that Request, all of its <code>UObject</code> instances will not be garbage collected. However, after said Operations/Waits are done, we'll no longer keep a reference to the Request's <code>UObject</code>. This means that, if you want to cache or use any <code>UObject</code> instance from the Response hierarchy, you need to keep a reference to the Request <code>UObject</code> yourself.   </p>"},{"location":"user-reference/runtime-systems/lower-level/#ubeamnotifications","title":"<code>UBeamNotifications</code>","text":"<p>Every Beamable player has an open WebSocket connection to the Beamable server while they are logged-in.  This system leverages UE's <code>WebSocket</code> module to open web-socket connections for each logged-in user (using <code>FUserSlot</code>).</p> <p>This WebSocket connection semantically represents the connectivity status for that particular user.  This means the SDK (and the Beamable Servers) think that a user is online/offline based on whether this connection is alive and well. Which in turn means that, if you want to use any of our real-time services (Matchmaking, Lobbies, etc...) this connection needs to be properly working. At runtime, <code>UBeamRuntime</code> and <code>UBeamConnectivityManager</code> handle per-<code>FUserSlot</code> Connectivity statuses.</p> <p>Aside from defining Connectivity semantics, this connection is also how the Beamable servers (or your own custom Microservices) send notifications to clients about certain events.</p> <p>For example:</p> <ul> <li>Implementations of <code>UEngineSubsystem</code> called <code>UBeam_____Notifications</code> exist for each Beamable Services (that emit notifications).<ul> <li>These expose two UE function versions, one BP-Compatible and the other Lambda-Compatible, that register a handler to process a specific type of notification.</li> </ul> </li> <li>These are used by that service's <code>UBeamRuntimeSubsystem</code> based on their semantic needs.<ul> <li>For example, <code>UBeamMatchmakingNotifications</code> subscribes to notifications for the matchmaking ticket while a <code>FUserSlot</code> is on a given queue.</li> </ul> </li> <li>You can use Microservices to send out custom notifications --- those can be received in clients by creating your own subsystem modeled after these.<ul> <li>Use <code>UBeamRuntime::SubscribeToCustomNotification</code> to subscribe to these easily at runtime. </li> </ul> </li> </ul>"},{"location":"user-reference/runtime-systems/operations-and-waits/","title":"Unreal SDK - Operations &amp; Waits","text":"<p>The Beamable SDK uses slight variation on Promises we named Operations.  These provide the same semantics as promises but their implementation is slightly different to allow for a BP-compatible API.</p> <p>They wrap concurrent operations (mostly HTTP Requests) under a <code>FBeamOperationHandle</code> exposed to some higher-level system. To put it in simpler terms:</p> <p>When you want to expose a single function that makes a bunch of requests and emits events as responses come in, ultimately handling success/failure of the entire sequence, use an Operation.</p> <p>We provide a lot of Operations inside our <code>UBeamRuntimeSubsystem</code> implementations; covering most basic use-cases. However, understanding how to create your own operations enables you to add behavior to last-mile hooks we expose. A couple of examples:</p> <ul> <li>\"I want to go talk to a microservice to fetch additional data for a user before the SDK's <code>UBeamRuntime::OnUserReady</code> callback.\"</li> <li>\"I want to go talk to a microservice to validate that you can actually join this matchmaking queue.\"</li> </ul> <p>Warning</p> <p>While possible, we don't recommend creating the actual operations as blueprints.  It's OK to do so for a quick experimentation session; but shipping with it is not recommended. Calling Operations that are written in C++ is the primary way we recommend Blueprints to interact with the Beamable SDK (we even have special nodes for it).</p>"},{"location":"user-reference/runtime-systems/operations-and-waits/#operation-lifecycle","title":"Operation Lifecycle","text":"<p>Every Operation has an <code>int64</code> id called the <code>FBeamOperationHandle</code>.  We use it to track the operation's state, its emitted events, its current status and which of Beamable's requests are part of it.</p> <p>The lifecycle of an operation goes as follows:</p> <p></p>"},{"location":"user-reference/runtime-systems/operations-and-waits/#writing-and-exposing-your-own-operations","title":"Writing and Exposing your Own Operations","text":"<p>We try and expose all of our main SDK operations in both BP and CPP flavors.  If you'd like to do the same thing, this section is for you. If you're looking for how to write hooks in C++, look into the next section.</p> <p>The primary trade-off is that: </p> <ul> <li>BP-Compatible versions do not allow for lambda binding and variable capturing. </li> <li>The CPP Version does allow for those things and, as they can be extremely useful for development speed and other cases, we decided on supporting both flavors.</li> </ul> <p>The snippet below explains how to write an operation for both BP and CPP; sharing its actual logic. </p> <pre><code>// This is the BP-Compatible Function\nFBeamOperationHandle U________::__________Operation(FUserSlot UserSlot, (...OperationParams...), FBeamOperationEventHandler OnOperationEvent, UObject* CallingContext)  \n{  \n    // First, we start an operation using the BP-Compatible BeginOperation call\n    const auto Handle = Runtime-&gt;RequestTrackerSystem-&gt;BeginOperation({UserSlot}, GetClass()-&gt;GetFName().ToString(), OnOperationEvent);  \n\n    // Then, we call a function that takes in the operation parameters and the Handle for the operation.\n    TheActualOperationLogic(UserSlot, (...OperationParams...), Handle);  \n\n    // Operation functions usually return the handle so that callers can ask questions about the state of the operation if they want to.    \n    return Handle;  \n}  \n\n// This is the CPP Function\nFBeamOperationHandle U__________::CPP_________Operation(FUserSlot UserSlot, (...OperationParams...), FBeamOperationEventHandlerCode OnOperationEvent, UObject* CallingContext)  \n{  \n    // First, we start an operation using the BP-Compatible BeginOperation call\n    const auto Handle = Runtime-&gt;RequestTrackerSystem-&gt;CPP_BeginOperation({UserSlot}, GetClass()-&gt;GetFName().ToString(), OnOperationEvent);  \n\n    // Then, we call a function that takes in the operation parameters and the Handle for the operation.\n    TheActualOperationLogic(UserSlot, Key, Value, Handle);  \n\n    // Operation functions usually return the handle so that callers can ask questions to UBeamRequestTracker about the state of the operation if they want to. \n    return Handle; \n}\n\n\nvoid U__________::TheActualOperationLogic(FUserSlot Slot, (...OperationParams...), FBeamOperationHandle Op)  \n{  \n    // This is mostly an example snippet of things you can do...\n\n    // We can check the local client state and fail operations without any request ever being made.\n    // For example, check if a user is authenticated or not.\n    FBeamRealmUser RealmUser;  \n    if (!UserSlots-&gt;GetUserDataAtSlot(Slot, RealmUser, this))  \n    {       \n    RequestTracker-&gt;TriggerOperationError(Op, TEXT(\"NO_AUTHENTICATED_USER_AT_SLOT\"));  \n    return;  \n    }  \n\n    // We can also prepare a request handler, capturing the \"Op\" Handle\n    const auto SomeRequestHandler = FOn______::CreateLambda([this, Op](F______ Resp)  \n    {  \n\n        // If the request is being retried, we don't do anything.\n        // But... we could go update a UI here or something...\n        if (Resp.State == RS_Retrying) return;\n\n        // If the request was successful, we can trigger the Operation as a success.\n        if (Resp.State == RS_Success)  \n        {\n            // (...) change local system's state            \n            RequestTracker-&gt;TriggerOperationSuccess(Op, {});  \n        }\n        // If the request failed, we can trigger the Operation as a success.\n        else \n        { \n            // (...) handle error and trigger the Operation as an error.\n            RequestTracker-&gt;TriggerOperationError(Op, Resp.ErrorData.error); \n        }\n    });    \n\n    // Make the request passing in the \"Op\" Handle (this tracks lets our UBeamBackend know not to clean up the request until the Operation has finished)\n    auto Ctx = Request____(Slot, (...ReqParams...), Op, SomeRequestHandler);\n}\n</code></pre> <p>Warning</p> <p>The parameter names <code>UserSlot</code>, <code>OnOperationEvent</code> and <code>CallingContext</code> are important!  They allow you to write your own implementation of our Beam Flow node for your operation.  Look at the Beam Flow Nodes section for more information on how to create these.</p> <p>There are tons of examples of operations in our SDK. For some guidance, you can take a look at any of our various runtime subsystems such as:</p> <ul> <li><code>UBeamStatsSubsystem</code></li> <li><code>UBeamInventorySubsystem</code></li> <li><code>UBeamLobbySubsystem</code></li> <li>Any other sub-class of <code>UBeamRuntimeSubsystem</code>.</li> </ul> <p>Feel free to copy-paste them as a template of how to implement and reason about <code>Operations</code>.</p>"},{"location":"user-reference/runtime-systems/operations-and-waits/#beam-flow-nodes-operations","title":"Beam Flow Nodes - Operations","text":"<p>There are two flavors of Beam-Flow nodes; one are Raw Requests that you can use to hit our APIs; the other is the Operation Beam Flow node. Operation Nodes look like this:</p> <p></p> <p>Beamable Operation Flow Nodes assume a few things:</p> <ul> <li>One or more participating <code>UserSlots</code> (see User Slots for more information).</li> <li>An event handler for handling any of the events.</li> <li>Events can be: <code>OET_SUCCESS</code>, <code>OET_ERROR</code> and <code>OET_CANCELLED</code> plus a <code>FName EventCode</code>.     </li> <li>Events can contain some arbitrary data associated with them (implementations of <code>IBeamOperationEventData</code>).</li> </ul> <p>To create these nodes for your own operations, you can look at any of our own nodes (that live inside our <code>UncookedOnly</code> module: <code>BeamableCoreBlueprintNodes</code> ) and copy/paste one implementation changing the values accordingly. However, there are a few restrictions:</p> <ul> <li>The function must be a <code>UFUNCTION</code> that returns a <code>FBeamOperationHandle</code> and contains the following named parameters:<ul> <li><code>FUserSlot UserSlot</code>, if a single user is involved in the operation, or <code>TArray&lt;FUserSlot&gt; UserSlot</code>, if multiple users are involved in the operation.</li> <li>If multiple users, the <code>UFUNCTION</code> must also add <code>meta=(BeamOperationMultiUser)</code>.</li> <li><code>FBeamOperationEventHandler OnOperationEvent</code> to be the event handler that will handle all events raised by the operation.</li> <li>The function can have any other parameters you want in any order as long as the above parameters are there.</li> </ul> </li> <li>The function must be declared from inside a <code>UGameInstanceSubsystem</code> / <code>UBeamRuntimeSubsystem</code> subclass.</li> </ul> <p>Here's an example of what you need to declare one of these (we recommend copying from your own SDK code instead of this snippet).</p> <pre><code>#define LOCTEXT_NAMESPACE \"K2BeamNode_Operation_CommitInventoryUpdate\"  \n\nUCLASS(meta=(BeamFlowNode))  \nclass UK2BeamNode_Operation_CommitInventoryUpdate : public UK2BeamNode_Operation  \n{  \n    GENERATED_BODY()  \n\n    // This returns the title of the node.\n    virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override { return LOCTEXT(\"Title\", \"Operation - Inventory - CommitInventoryUpdate\"); }  \n\n    // This should get a static UFUNCTION that returns a valid instance of the UGameInstanceSubsystem containing the Operation function.\n    virtual FName GetSubsystemSelfFunctionName() const override { return GET_FUNCTION_NAME_CHECKED(UBeamInventorySubsystem, GetSelf); }  \n\n    // This should return the UFUNCTION Operation's name.\n    virtual FName GetOperationFunctionName() const override { return GET_FUNCTION_NAME_CHECKED(UBeamInventorySubsystem, CommitInventoryUpdateOperation); }  \n\n    // This should get the UGameInstanceSubsystem class\n    virtual UClass* GetRuntimeSubsystemClass() const override { return UBeamInventorySubsystem::StaticClass(); }  \n\n};  \n\n#undef LOCTEXT_NAMESPACE\n</code></pre> <p>As long as you have one of these in an <code>UncookedOnly</code> module of your application, you should be able to expose your own operations as BP nodes (this is compatible with Multiplayer PIE mode).</p>"},{"location":"user-reference/runtime-systems/operations-and-waits/#writing-hooks","title":"Writing Hooks...","text":"<p>... and other <code>FBeamOperationHandle</code> returning functions.  These are the various callback flavors that we expose so you can customize your experience with our SDK. In other words:</p> <p>If you ever see a Delegate or Virtual Function that you can implement that returns one or more <code>FBeamOperationHandle</code>, you need to create operations and return their handles so that we can wait on your code before we proceed with ours. It's basically a way for you to inject a promise that we'll run as part of a larger process.</p> <p>There are a few flavors of this around the SDK:</p> <ol> <li>Delayed Operation: It's basically a simple parameter-less callback that returns a <code>FBeamOperationHandle</code> our SDK should wait for.<ol> <li>See our <code>UBeamRuntime::LoginGuest</code> function for an example of this.</li> </ol> </li> <li>Runtime Subsystem Implementation: Implementations of virtual functions in one of our SDK's base classes such as <code>UBeamRuntimeSubsystem</code>.<ol> <li>This is for when you wish to make a system that ties into the Beamable life-cycle like our own <code>UBeamRuntimeSubsystem</code> implementations do.</li> <li>This is rarely needed, but... in unique custom use-cases, it's likely to be the best way to accomplish your goals.</li> </ol> </li> <li>Hooks: Bind into delegates created via <code>DEFINE_BEAM_OPERATION_HOOK</code>.<ol> <li>We don't use Hooks ourselves IN ANY CIRCUNSTANCES and leave these as \"game-maker-only extensions\".</li> <li>You can search for <code>DEFINE_BEAM_OPERATION_HOOK</code> and find some usages of the macro to better understand these. </li> </ol> </li> </ol>"},{"location":"user-reference/runtime-systems/operations-and-waits/#beam-operation-hooks","title":"Beam Operation Hooks","text":"<p>Hooks have some more context that you should know about how to use them:</p> <ol> <li>You call some Operation we expose in our SDK. That Operation does a bunch of things and triggers the hooks at some well-known point during their execution.<ol> <li>Since you have the source code, you can look into these functions and see the exact semantics of the trigger, but we do try and keep these documented in call-site comments.</li> </ol> </li> <li>Whenever a set of hooks are triggered, what we are actually doing is:<ol> <li>The returned <code>FBeamOperationHandles</code> from the hooks are fed into a <code>UBeamRequestTracker::WaitAll</code> call.</li> <li>Our operation will wait for all your hooks to complete; successfully or otherwise.</li> <li>If your registered operations fail, we'll log out the errors that exist inside those operations and let you know clearly the problem happened in the operation you provided to the hook.</li> <li>If your operations succeeded, we'll continue with our own operation and eventually trigger that as a success.</li> <li>The semantics of what happens in case of a failure change from hook to hook, but... for the most part, we'll fail our own operation if any hooks fail.</li> </ol> </li> </ol> <p>Here's a \"template example\" of how this stuff will typically look like:</p> <pre><code>// Let's say you want to run some synchronous code at a hook but don't really want to make any request to anything.\n// In that case you can get the system and add a hook that:\nconst U_____ SomeSystem;  \nSomeSystem-&gt;Hook.Add(F____::CreateLambda([this]()  \n{  \n    // (...) Does some synchronous code\n    // This means that your operation is completed at the end of this function\n\n    // For cases like these, we provide the utility function below.\n    // This creates and immediately completes an operation and returns its handle.\n    return GEngine-&gt;GetEngineSubsystem&lt;UBeamRequestTracker&gt;()-&gt;CPP_BeginSuccessfulOperation({}, FString(\"MySystemName\"), FString(\"\"), FBeamOperationEventHandlerCode{});  \n}));  \n\n// Let's say you want to call some microservice you wrote as part of our operation\n// In that case you can add a hook that:\nSomeSystem-&gt;Hook.Add(F____::CreateLambda([this]()  \n{  \n    // Begins an operation\n    const auto Op = GEngine-&gt;GetEngineSubsystem&lt;UBeamRequestTracker&gt;()-&gt;CPP_BeginOperation({}, FString(\"MySystemName\"), {});\n\n    // Get Microservice Subsystem that exposes calls to it\n    const auto MyMsApi = GEngine-&gt;GetEngineSubsystem&lt;UMyMsApi&gt;();  \n    const auto MyMsReq = UMyMsRequest::Make(GetTransientPackage(), {});  \n\n    // Create the handler for the request capturing the \"Op\" its a part of.\n    const auto MyMsHandler = FOnMyMsFullResponse::CreateLambda([this, Op](FMyMsFullResponse Resp)  \n    {       \n        // If we timedout and are retrying the request, do nothing.\n        if(Resp.State == RS_Retrying)  \n            return;         \n\n        UE_LOG(LogTemp, Display, TEXT(\"Talked to a Microservice from a Hook!!!! Look at that, huh?\"));  \n\n        // If the response from the Microservice was not a success, fail the operation.\n        if(Resp.State != RS_Success)  \n        {   \n            // Trigger the operation as a success\n            GEngine-&gt;GetEngineSubsystem&lt;UBeamRequestTracker&gt;()-&gt;TriggerOperationError(Op, Resp.ErrorData.message);  \n            return;  \n        }  \n\n        // (...) Do stuff with the Microservice's response\n\n        // Trigger the operation as a success\n       GEngine-&gt;GetEngineSubsystem&lt;UBeamRequestTracker&gt;()-&gt;TriggerOperationSuccess(Op, FString(\"\"));  \n    });   \n\n    // Make the request\n    FBeamRequestContext Ctx;  \n    MyMsApi-&gt;CPP_MyMs(UserSlot, MyMsReq, MyMsHandler, Ctx, Op, GetGameInstance());  \n\n    // Return the create Operation\n    return Op;  \n}));\n</code></pre>"},{"location":"user-reference/runtime-systems/operations-and-waits/#why-not-template-based-promises","title":"Why not Template-based Promises?","text":"<p>The biggest reason not to do that is Blueprint Compatibility. The most recognizable template-based Promise-style API just won't work with BPs. As such, we wanted to create an underlying system that provided the same functionality but that retained BP compatibility even if it lost the template-based interface. The result was this Operation system.</p> <p>Info</p> <p>In using it inside our own SDK to develop our Stateful <code>UBeamRuntimeSubsystems</code>, we found that we didn't miss the template aspect or its chaining aspect of <code>Do().Then()</code>. However, the chaining might be something we eventually look into. Perhaps adding the ability to chain requests like these as \"syntactic sugar\"; but its highly unlikely we'll do anything with templates at the Operation-layer as we do not want to lose the BP-Compatibility.</p>"},{"location":"user-reference/runtime-systems/operations-and-waits/#waits","title":"Waits","text":"<p>This is equivalent to <code>Promise.All</code> or <code>Task.WhenAll</code> keeping with our promise analogy. It can be used to wait on a set of operations and/or requests executed concurrently whose errors and successes are handled all at once.  To use this, call <code>UBeamRequestTracker::[CPP_]WaitAll</code>.</p> <p>This function takes arrays of <code>FBeamRequestContext</code>, <code>FBeamOperationHandle</code> and/or <code>FBeamWaitHandle</code> and a handler function. It'll wait until all the provided handles are completed and then gather all emitted events and request responses and invoke your handle function passing in a helper struct to identify successes/failures.</p> <p>You can find examples of these in our SDKs so you can learn how to use this yourself. The most common examples are:</p> <ul> <li><code>UBeamRuntime</code>'s Initialization and Login's Lifecycle is defined as a multi-step operation with several wait points.</li> <li><code>UBeamContentSubsystem</code> also has an example around how we fetch content updates.</li> </ul> <p>Understanding these concepts and how to leverage them can unlock the maximum potential uses and customizability of the SDK; but superficial knowledge is sufficient for the most basic use-cases.  Take your time and refer back to this page as you need!</p>"},{"location":"user-reference/runtime-systems/user-slots/","title":"User Slots","text":"<p>User Slots are at the core of how the SDK handles local users. Each <code>UserSlot</code> is a named slot that represents a local user. These are defined in <code>UBeamCoreSettings::RuntimeUserSlots</code> (found in <code>Project Settings -&gt; Engine</code>).  They are used to organize local data caches for a single Beamable user. These are stored in Unreal's default <code>Saved</code> folder.</p> <p>Almost all of our APIs take in a <code>FUserSlot</code> struct representing the local user making the request.  Only \"public\" APIs do not require them (APIs that you can call after the SDK has been initialized but before any login has happened).</p> <p>If you're game has no local multiplayer (just a single local player), you only need to know a few things about them:</p> <ul> <li>By default, in C++, you should pass in the <code>UBeamCoreSettings::GetOwnerPlayerSlot()</code> (which defaults to <code>\"Player0\"</code>).</li> <li>In Blueprints, you'll only have to manually pass in user slots if you change the default slot from <code>\"Player0\"</code>.</li> <li>If you're using any of our lower-level APIs (<code>UBeam____Api</code> subsystems), you might see functions that take in a <code>UObject* ContextObject</code>.<ul> <li>These are there to support Unreal's Multiplayer PIE mode (for the same reason a lot of UE's own APIs also need one of these).    </li> <li>If you're calling them from a <code>UGameInstanceSubsystem</code>, <code>UActorComponent</code> or <code>AActor</code>, passing itself (<code>this</code>) to this parameter is the simplest approach.</li> </ul> </li> </ul> <p>Non-Local Multiplayer Games</p> <p>If you're game is a normal one-player-per-client multiplayer game, you might want to take a look at our Matchmaking and Lobbies systems.</p>"},{"location":"user-reference/runtime-systems/user-slots/#user-slots-at-runtime","title":"User Slots At Runtime","text":"<p>The <code>UBeamUserSlots</code> Engine Subsystem is responsible for:</p> <ul> <li>Storing the authentication tokens for the last account that logged into a particular slot.<ul> <li>These are kept in Unreal's default <code>Saved</code> directory.</li> </ul> </li> <li>Enabling local co-op games to have multiple players logged in at the same time.<ul> <li>For more on login flows, see the SDK Lifecycle and various flavors described in Identity. </li> </ul> </li> <li>Handles support for Multiplayer PIE-mode by namespacing each Slot (UE's <code>FWorldContext::WorldType</code> and <code>FWorldContext::PIEInstance</code>).<ul> <li>To do so, we need to find an <code>UWorld</code> to get the context from.</li> <li>This is why, like UE, we take in a <code>UObject* CallingContext</code> in certain parts of our APIs.</li> <li>At runtime, this parameter is NEVER optional!</li> </ul> </li> <li>Assert that only slots defined in the <code>UBeamCoreSettings</code> are in use.<ul> <li>Any User Slot with <code>Test</code> in its name is exempt from this rule so you can write automated tests with arbitrary amounts of user slots by using user slots with <code>Test</code> in their names.</li> </ul> </li> </ul> <p>This subsystem does not handle the actual logging in and logging out. That is handled by two other Subsystems:</p> <ul> <li><code>UBeamRuntime</code> , a <code>GameInstanceSubsystem</code>, is responsible for PIE instances and packaged games.</li> <li><code>UBeamEditor</code>, an <code>EditorSubsystem</code>, is responsible for the Editor integration.</li> </ul>"},{"location":"user-reference/servers-and-builds/dedicated-servers/","title":"Dedicated Servers","text":""},{"location":"user-reference/servers-and-builds/dedicated-servers/#overview","title":"Overview","text":"<p>The Beamable Unreal SDK was made with support for a dedicated servers in mind from the start. We also develop and maintain a simple Sample Project containing a <code>Dockerfile</code> for a Linux server container builds and a microservice example of how to integrate with a third-party Game Server Orchestrator such as Hathora.</p>"},{"location":"user-reference/servers-and-builds/dedicated-servers/#sdk-dedicated-server-initialization","title":"SDK Dedicated Server Initialization","text":"<p>By default, each dedicated server instance it is expected to run a single lobby. When the server starts up, you should call <code>UBeamRuntime::InitSDK</code>. The SDK will look for some overrides and parameters coming in from Environment Variables OR Command-Line Arguments. Command Line Arguments override Environment Variables when both are present.</p> <p>The table below describe these overrides and what they are for:</p> Value CLArg/EnvVar Realm Secret CLArg: <code>beamable-realm-secret</code>EnvVar: <code>BEAMABLE_REALM_SECRET</code>This is a high-security token that can be found in: <code>Portal -&gt; Games -&gt; Any Realm (...) -&gt; Project Secret</code> OR by running <code>dotnet beam config secret</code> from your project root.Be very careful with this and DON'T commit it to your version control. CID CLArg: <code>beamable-customer-override</code>EnvVar: <code>BEAMABLE_CUSTOMER_OVERRIDE</code>This is mostly here so you can point our Sample builds to your organization; has little bearing on your own games. PID CLArg: <code>beamable-realm-override</code>EnvVar: <code>BEAMABLE_REALM_OVERRIDE</code>This defines with which of your realms the server will attempt to communicate. Make sure this matches the Realm Secret. Lobby ID CLArg: <code>BeamableDedicatedServerInstanceLobbyId</code>EnvVar:<code>BEAMABLE_DEDICATED_SERVER_INSTANCE_LOBBY_ID</code>The Lobby ID for the match that'll happen in this server. <p>Multiple Lobbies per Server Instance</p> <p>If no Lobby ID is provided via the CLArg, we assume you'll manage fetching lobby data yourself via <code>UBeamLobbySubsystem::CPP_RefreshLobbyDataOperation</code>. You can use this to manage multiple lobbies per-instance in ways more specific to your game.</p>"},{"location":"user-reference/servers-and-builds/dedicated-servers/#differences-from-game-client","title":"Differences from Game Client","text":"<p>The SDK works a bit different when its running inside a Dedicated Server and the way we recommend you integrate your server-authoritative logic is a bit different. This section explains these differences.</p>"},{"location":"user-reference/servers-and-builds/dedicated-servers/#user-slots","title":"User Slots","text":"<p>User Slots are a big part of the regular workflow when working with Beamable SDK in game clients. For dedicated servers though they are not used. For interfaces containing the <code>UserSlot</code> parameter, that parameter can be ignored.</p> <p>This means a few things:</p> <ul> <li>There is no need to <code>SignUp</code>/<code>Login</code>; just to <code>InitSDK</code>.</li> <li>Calling APIs that simply read data from users via their <code>GamerTag</code> or other Ids will work fine.</li> <li>Calling APIs that write to user data is not recommended via regular SDK functions (see below for the alternative).</li> </ul>"},{"location":"user-reference/servers-and-builds/dedicated-servers/#writing-user-state","title":"Writing User State","text":"<p>The current recommended way of changing user state from dedicated server code is to write a <code>ServerCallable</code> functions in Microservices and invoking those. See Microservices for more information about the various types of <code>Callable</code>.</p>"},{"location":"user-reference/servers-and-builds/dedicated-servers/#microservices-federation","title":"Microservices &amp; Federation","text":"<p>Beamable does not provide Game Server Orchestration. This means that, while we have Lobbies, Matchmaking and can find matches between players, we do NOT run the actual Game Server. For this, we partner with other companies and provide a simple way to integrate our Matchmaking and Lobbies with them.</p> <p>You can read more about this in the Federated Game Server guide, but conceptually here's what happens:</p> <ol> <li>Players are in a Matchmaking queue or Lobby.</li> <li>A Match is found or a Lobby leader asks for a Game Server for their match.</li> <li>The Beamable Backend calls a Microservice (configured via the <code>UBeamGameTypeContent</code>).<ol> <li>This call is expected to provision the game server and return a <code>ServerInfo</code> object.</li> <li>This object should contain all sorts of information for the match including connection information.</li> <li>The data in this object gets appended to the Lobby's <code>GlobalData</code> and Lobby Player's <code>Tags</code>.</li> <li>When the Game Server Instance starts up, the SDK fetches the Lobby data for the match and these properties will be there.</li> </ol> </li> <li>The Beamable Backend then notifies all relevant game clients that the server is ready.</li> <li>The SDK detects that and invokes a callback where you can read set properties.</li> </ol> <p>Our Hathora Sample Project contains example of the flow above.</p>"},{"location":"user-reference/servers-and-builds/linux-builds/","title":"Linux Builds workflow","text":"<p>This guide will provide a way to get a working Linux build on Windows.</p> <p>Building from Docker</p> <p>While it is possible to build game using a Docker, we found that solution suboptimal compared to the one described in this guide.</p>"},{"location":"user-reference/servers-and-builds/linux-builds/#cross-compilation","title":"Cross Compilation","text":"<p>Windows only</p> <p>Cross-compiling in Unreal world is limited to Windows only. On Linux you can compile only Linux target, same for Mac users.</p> <p>In order to get cross compilation to work it requires: 1. Go to Unreal docs page that contains toolchains, download and install the <code>Cross-Compile Toolchain</code> that matches version of Unreal Engine you are using. 2. Update environment variables by adding new variable <code>LINUX_MULTIARCH_ROOT</code> with value being the path to the newly installed toolchain. It should be something like <code>F:\\UnrealToolchains\\v22_clang-16.0.6-centos7</code>. 3. Now when game is open in editor it should be possible to build for the <code>Linux</code> Target platform:</p> <p></p>"},{"location":"user-reference/servers-and-builds/linux-builds/#testing-the-build","title":"Testing the build","text":"<p>In order to test Linux game builds using other machine with Linux installed is recommended.  For the server ones it is easy to test them on Windows machine in two different ways.</p>"},{"location":"user-reference/servers-and-builds/linux-builds/#wsl","title":"WSL","text":"<p>WSL is a feature of Windows for running a Linux environment on Windows machine, without Docker.</p> <p>Note</p> <p>This part of tutorial is written with assumption that WSL is installed and operational.</p> <ol> <li>Build Linux Server target build of the game.</li> <li>Open <code>Windows Subsystem for Linux</code> console in <code>LinuxServer</code> directory of the build. <ol> <li>It should contain an <code>Engine</code> folder, a <code>ProjectName</code> folder and a script file with filename in format: <code>{ProjectName}Server.sh</code>.</li> </ol> </li> <li>Run the script file: <code>./{ProjectName}Server.sh</code>.</li> <li>Server should be up and running.</li> </ol>"},{"location":"user-reference/servers-and-builds/linux-builds/#docker","title":"Docker","text":"<p>Docker is often used by Game Server Orchestrators for running built Game Servers. Beamable does provide a working example of that workflow in Hathora Sample.</p> <p>Note</p> <p>This part of tutorial is written with assumption that Docker is installed and operational.</p> <ol> <li>Build the game's Linux Server target.</li> <li>Open <code>LinuxServer</code> directory of the build.<ol> <li>It should contain an <code>Engine</code> folder, a <code>ProjectName</code> folder and a script file with filename in format: <code>{ProjectName}Server.sh</code>.</li> </ol> </li> <li>Create <code>Dockerfile</code> file in <code>LinuxServer</code> directory.</li> <li>Copy the file contents below to the created <code>Dockerfile</code>.<ol> <li>Don't forget to update the paths to match your project!</li> </ol> </li> </ol> <pre><code>FROM ubuntu:22.04\n\n# Add these dependencies to enable your server to make outbound TLS requests\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y ca-certificates &amp;&amp; \\\n    update-ca-certificates\n\nRUN groupadd --gid 1000 unreal \\\n  &amp;&amp; useradd --uid 1000 --gid unreal --create-home unreal\nUSER unreal\n\n# Copy the Unreal game server contents\nWORKDIR /home/unreal\nCOPY --chown=unreal:unreal . .\n\nRUN chmod +x {ProjectName}Server.sh\nRUN chmod +x {ProjectName}/Binaries/Linux/{ProjectName}Server\n\n# Expose the Unreal game server port\nEXPOSE 7777/udp\n\n# Start init script (passing any parameters you need)\nENTRYPOINT [ \"./{ProjectName}Server.sh\", \"-custom_parameter=SOME_VALUE\" ]\n</code></pre> <ol> <li>Open command line in <code>LinuxServer</code> directory and run this command: <code>docker build -t my_server .</code>.</li> <li>Now it is possible to run the server build with command: <code>docker run -t my_server</code>.</li> </ol>"},{"location":"whatsnew/1.0.0/","title":"1.0.0","text":""},{"location":"whatsnew/1.0.0/#migrating-from-100-preview","title":"Migrating from 1.0.0 PREVIEW","text":"<p>We highly recommend you start this process with no staged changes to your VCS and in an isolated local branch such that you can revert as needed.</p> <ul> <li>Download/Clone our Tagged Release.</li> <li>Extract it to a location in the same drive as your project.</li> <li>Copy/Paste the <code>beam_game_maker_init.sh</code> into your project's root (next to your <code>.uproject</code> file).</li> <li>Open a shell (we recommend <code>GitBash</code> if you're using <code>git</code>) in your project root directory.</li> <li>Run that script passing in the path to our extracted project.</li> </ul> <pre><code># If you just want to install the BeamableCore plugin (no OnlineSubsystem)\n. beam_game_maker_init.sh \"/e/Path/To/Unreal/SDK/Root/Folder\"\n\n# If you want to install OnlineSubsystemBeamable Plugin too (or had it installed).\n. beam_game_maker_init.sh \"/e/Path/To/Unreal/SDK/Root/Folder\" true\n</code></pre> <p>Access Denied</p> <p>Unreal's integrations with various version control systems will sometimes make files Read-Only at the OS-level. If this is the case, you may see an <code>Access Denied</code> error when running the above script. Part of that script is deleting the old <code>Plugins/BeamableCore</code> folder and some of the <code>uasset</code>/<code>umap</code> files inside it might be flagged as read-only. To fix this, revert the changes, go to the <code>Plugins/BeamableCore</code>, and optionally <code>Plugins/OnlineSubsystemBeamable</code>, search for <code>uasset</code>/<code>umap</code> files and make them NOT read-only. On Windows, this can be done by the \"Properties\" panel of the file.</p> <p>Please contact our customer support if the above does not work.</p> <p>If the script is successfull, you should see something like this:</p> <pre><code>Found .uproject: ./YourProject.uproject\n\nInstalling the SDK in your project: YourProject\nTool 'beamable.tools' is up to date (version '3.0.1' manifest file E:\\Path\\To\\Your\\.config\\dotnet-tools.json) .\nBeamable Tools are installed. To call them use \"dotnet beam\" from any directory under your Unreal project root.\nAlready installed BeamableCore plugin. Removing it so we can re-install it.\nInstalled BeamableCore plugin.\n\n# If you're using OnlineSubsystemBeamable, you should see these lines...\nAlready installed OnlineSubsystemBeamable plugin. Removing it so we can re-install it.\nCopying OnlineSubsystemBeamable plugin's Beamable Content folder.\nCopying OnlineSubsystemBeamable plugin's Build.cs file.\nCopying OnlineSubsystemBeamable plugin's Source/OnlineSubsystemBeamable/Beamable files.\nInstalled OnlineSubsystemBeamable plugin.\n\n# This means that we successfully upgraded your CLI and SDK version\nInstalled Beamable SDK successfully.\n</code></pre> <p>Now, if you have microservices, do the following steps. If not, skip to the next section.</p> <ul> <li>Open a shell inside your project root and run: <code>dotnet tool restore</code>.</li> <li>Unlink the Unreal Project by deleting the <code>.beamable/linked-projects.json</code> file.</li> <li>Link it again using <code>dotnet beam project add-unreal-project .</code></li> <li> <p>Disable Automatic code Generation by setting <code>&lt;GenerateClientCode&gt;false&lt;/GenerateClientCode&gt;</code> in every service's <code>csproj</code> file.        </p> </li> <li> <p>Follow the CLI upgrade guide found here to ensure your microservice is now correctly configured.</p> </li> <li> <p>Run your microservice from Rider to verify the upgrade worked.</p> </li> <li> <p>If you want, re-enable Automatic Code Generation by setting <code>&lt;GenerateClientCode&gt;true&lt;/GenerateClientCode&gt;</code> in every service's <code>csproj</code> file.</p> </li> <li>If you don't want, you can read about manual generation here</li> </ul> <p>In the Unreal Solution:</p> <ul> <li> <p>There were a number of renames and changes, so the project is likely NOT compiling at this point; if most of your work was in Blueprints, those may not be compiling even if the editor is.</p> </li> <li> <p><code>Target.cs</code> file and <code>Beam.Configure___</code> functions</p> <ul> <li>We now add code to your project's <code>Target.cs</code> file. This code is callable from any <code>Target.cs</code> and <code>Build.cs</code> files.</li> <li>Before, you had to manually add the various <code>BeamableCore</code> modules to these things by hand. Now, you can call the respective functions based on the Type of <code>Target</code> or <code>Module</code>.</li> <li>You can refer to the intro guide to see which functions can be called in which <code>Target</code>/<code>Modules</code>.</li> </ul> </li> </ul> <p>Initialization is now manual in all cases.</p> <ul> <li>Instead of <code>RegisterOnStarted</code>/<code>RegisterOnReady</code>, you should explicitly invoke: <code>InitSDK</code> or <code>InitSDKWithFrictionlessAuth</code>.<ul> <li><code>RegisterOnReady</code> no longer exists. Its semantics were hard to explain and provided little benefits.<ul> <li>It was replaced by <code>RegisterOnUserReady</code>.</li> <li>The semantics for this is: \"runs at the end of every user's login process, when all the <code>UBeamRuntimeSubsystems</code> have already prefetched data for that user\".</li> </ul> </li> <li><code>RegisterOnStarted</code> remains the same.</li> <li>A few delegates have been renamed for clarity:<ul> <li><code>FRuntimeStateChangeHandler</code> =&gt; <code>FBeamRuntimeHandler</code></li> <li><code>FUserStateChangedCode</code>=&gt; <code>FUserStateChangedHandlerCode</code></li> </ul> </li> <li>We removed <code>IsFirstAuth</code> and <code>bDidFirstAuthRun</code> in favor of a simpler <code>IsLoggedIn(FUserSlot)</code> function with which you can build.<ul> <li>The new semantics are slightly different and just tell you that there's a user in that slot or not; you are free to handle \"Return to main menu\" situation as you wish.</li> </ul> </li> <li>Read more about the initialization flow here.</li> </ul> </li> </ul> <p>Microservice Clients suffered a MAJOR change.</p> <ul> <li>Microservices are now generated into their own exclusive Plugin. This makes the Microservice Client code accessible from any other Plugin or Module in your project.</li> <li>This means a few things:<ul> <li>You must add this plugin to all relevant <code>Target.cs</code> and <code>Build.cs</code>.</li> <li>You must add this plugin to your Project's <code>.uproject</code> file (can be done via the editor, but since you might not be able to compile --- you can do it manually too).</li> <li>If you were using OnlineSubsystemBeamable:<ul> <li>Delete the <code>AutoGen</code> folder from inside the <code>Customer</code> directory.</li> <li>Add the <code>MicroserviceNameMicroserviceClients</code> plugin as a dependency to the OnlineSubsystemBeamable plugin.</li> </ul> </li> </ul> </li> <li>If you haven't already, regenerate the microservice clients via by rebuilding them (or running the <code>dotnet beam generate-client</code> command).<ul> <li>This will create a new Plugin in your project called <code>MicroserviceNameMicroserviceClients</code>.</li> <li>This Plugin can be added to any other Plugin or your own project to gain access to the microservice clients and types.</li> <li>About code-changes:<ul> <li>The new clients no longer prefix every generated type with <code>MicroserviceName</code>; it only does so for the Request types.</li> <li>You'll have to go through the code and use the newly generated types.</li> <li>This change was made to provide you with more control over naming data-types shared between microservice and Unreal and reduce the common-case verbosity of these names.</li> <li>This means you can fix name conflicts as they appear in your project instead of us preemptively doing it.</li> </ul> </li> </ul> </li> </ul>"},{"location":"whatsnew/1.1.0/","title":"Version 1.1.1 - Hotfix","text":"<p>This is the release notes for the The Unreal SDK version 1.1.1 (hotfix).</p>"},{"location":"whatsnew/1.1.0/#fixes","title":"Fixes","text":"<ul> <li>Fixed issue with SignUpEmailAndPassword where it would incorrectly attach email the email as an URL encoded email.</li> <li>Fixed issue with AnnouncementSubsystem where <code>UAnnouncementView*</code> objects in the subsystem could be garbage collected out from under the system. This fix required a small API breaking change:<ul> <li>The <code>UBeamAnnouncementsSubsystem::GetAnnouncements</code> function now returns a <code>FBeamAnnouncementsState</code> containing the array of <code>UAnnouncementView*</code>.</li> <li>There are no semantic differences however and the list inside <code>FBeamAnnouncementsState</code> is semantically the same as from the previous version.</li> </ul> </li> <li>Fixed issue of <code>UBeamRuntime::SendAnalyticsEvent</code> sending the incorrect names of the event structure.  </li> </ul>"},{"location":"whatsnew/1.1.0/#version-110","title":"Version 1.1.0","text":"<p>This is the release notes for the The Unreal SDK version 1.1.0.</p> <p>While it's considered a minor release in our release cycle, it brings a lot of new features and improvements to the Beamable Unreal SDK and user experience in general including many UI/UX improvements on the build-in editor window, reworked LiveOps demo, new Documentation website and many improvements on the codebase including new <code>OnlineSubsystemBeamable</code> features, and many bug fixes. You can see the full list of changes below.</p>"},{"location":"whatsnew/1.1.0/#highlights","title":"Highlights","text":""},{"location":"whatsnew/1.1.0/#new-beamable-editor-window","title":"New Beamable Editor Window","text":"<p> The Beamable Editor Window was reworked making it easier to use the Beamable Systems in your project. Now you can easily access Home, Content and Microservices using fixed tabs on the top of the window without effort.</p>"},{"location":"whatsnew/1.1.0/#new-content-editor","title":"New Content Editor","text":"<p> The Content Editor received a complete rework improving the usability and fixing many bugs. Now the content is presented in a list of itens improving the visualization of large amount of data; The filters were fixed on the top and the search is now a <code>Contains</code> search instead of a <code>StartsWith</code> search. Also, all changes in the data are now updated properly with realtime feedbacks without need to reload the window manually. You can check the new Content Editor Documentation here</p>"},{"location":"whatsnew/1.1.0/#new-connectivity-management-utilities","title":"New Connectivity Management Utilities","text":"<p>In this version, the SDK now exposes utilities to assist you in dealing with loss of connectivity to the Beamable servers. These utilities allow you to gracefully respond to connection losses and instability. For more details, check out this page.</p>"},{"location":"whatsnew/1.1.0/#new-unreal-documentation","title":"New Unreal Documentation","text":"<p> The Unreal Documentation was reorganized and improved to better guide the users on how to use the Beamable System in your project. More improvements in the Documentation of all Beamable Products are coming soon.</p>"},{"location":"whatsnew/1.1.0/#new-liveops-sample","title":"New LiveOps Sample","text":"<p> The LiveOps Sample was improved with new UI and information. You can check the new LiveOps Sample Documentation here</p>"},{"location":"whatsnew/1.1.0/#other-changes","title":"Other Changes","text":"<ul> <li><code>OnlineSubsystemBeamable</code> plugin now supports Frictionless Authentication and Identity Attaching.<ul> <li>This is the last feature update to this subsystem as it is now discontinued. </li> </ul> </li> <li>Samples are now selected by running <code>dotnet beam unreal select-sample BEAMPROJ_Name</code> instead of <code>BeamProjOverride.txt</code></li> <li><code>beam_init_game_maker.sh</code> will now try to remove any read-only flags of files inside the existing <code>Plugins/BeamableCore</code> folder.   This is needed because UE's integrations with VCSs (Git, P4) will often lock binary files at the file system level; which then   leads to our CLI being unable to replace the folder with newer versions (due to \"access denied\" problems). If you are using a VCS that   makes files read-only at the file-system level, and you run into \"access denied\" issues when running this script, please make them not read-only and try again.</li> <li><code>UBeamNotifications::TrySubscribeForMessage</code> now also accepts any type implementing <code>IBeamJsonSerializableUObject</code> for its message type.   This enables usage of the <code>BeamGenerateSchema</code> attribute in microservice code to keep custom notification payloads in-sync between Microservice and UE code.</li> <li>Added support for serializing <code>FColor</code>, <code>FLinearColor</code>, <code>FVector</code> and <code>FIntVector</code> inside <code>UBeamContentObject</code>types.</li> <li>Local Microservices started from the Unreal editor will now correctly terminate when the editor closes</li> </ul>"},{"location":"whatsnew/1.1.0/#fixes_1","title":"Fixes","text":"<ul> <li>Fixed issue that could cause an internal engine check to fail during editor startup in very rare cases (PostObjectLoad issue).</li> <li>Fixed issue that could cause a crash when re-logging into any particular UserSlot (a cleaned up operation could be waited on; no longer possible now)</li> <li>Fixed an issue that would cause a subsystem initialized with <code>UBeamRuntime::ManuallyInitializeSubsystem</code> to not load its user's data correctly if the user signed in after the system was initialized.</li> <li>Fixed multiple cases where the Content Screen did not update automatically after changes</li> </ul>"},{"location":"whatsnew/1.1.0/#known-issues","title":"Known Issues","text":"<ul> <li>When creating a custom event by hand, adding a <code>FUserSlot</code> parameter pin to that event can sometimes crash the engine. This also seems to happen with some Unreal types that have custom pins (the same crash happens with <code>bool</code> pins, though less frequently).<ul> <li>This does NOT happen if you create the event using the functionality in the <code>CreateEvent</code> node OR by any other means of creating a custom event with all the pins it knows it should have.</li> <li>This crash also seems less likely to happen the longer the editor stays open. </li> </ul> </li> </ul>"}]}