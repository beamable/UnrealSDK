using System;
using System.Linq;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Server;
using Beamable.SuiFederation.Endpoints;
using Beamable.SuiFederation.Features.Accounts;
using Beamable.SuiFederation.Features.Notifications;
using Beamable.SuiFederation.Features.Notifications.Models;
using Beamable.SuiFederation.Features.Transactions.Storage;

namespace Beamable.SuiFederation.Features.Inventory;

public class UpdatePlayerStateService : IService
{
    private readonly AccountsService _accountsService;
    private readonly IBeamableRequester _beamableRequester;
    private readonly GetInventoryStateEndpoint _inventoryStateEndpoint;
    private readonly TransactionLogCollection _transactionLogCollection;
    private readonly PlayerNotificationService _playerNotificationService;

    public UpdatePlayerStateService(AccountsService accountsService, IBeamableRequester beamableRequester, GetInventoryStateEndpoint inventoryStateEndpoint, TransactionLogCollection transactionLogCollection, PlayerNotificationService playerNotificationService)
    {
        _accountsService = accountsService;
        _beamableRequester = beamableRequester;
        _inventoryStateEndpoint = inventoryStateEndpoint;
        _transactionLogCollection = transactionLogCollection;
        _playerNotificationService = playerNotificationService;
    }

    public async Task Update(IPlayerNotification notification, UserRequestDataHandler user)
    {
        try
        {
            var transactionLog = await _transactionLogCollection.GetByInventoryTransaction(notification.InventoryTransactionId);
            if (transactionLog is not null && transactionLog.MintedTimestamp is null)
            {
                await _transactionLogCollection.SetMintedDone(transactionLog.Id);
                var gamerTag = await GetGamerTag(transactionLog.Wallet);
                if (gamerTag == 0)
                    gamerTag = transactionLog.RequesterUserId;
                await SynchronizeState(gamerTag, transactionLog.Wallet);
                await _playerNotificationService.SendPlayerNotification(gamerTag, notification);
            }
        }
        catch (Exception e)
        {
            BeamableLogger.LogException(e);
        }
    }

    private async Task SynchronizeState(long gamerTag, string walletAddress)
    {
        try
        {
            var newState = await _inventoryStateEndpoint.GetInventoryState(walletAddress);
            BeamableLogger.Log("Reporting back state for user {gamerTag}", gamerTag);
            await _beamableRequester.Request<CommonResponse>(Method.PUT, $"/object/inventory/{gamerTag}/proxy/state", newState, includeAuthHeader: false);
        }
        catch (Exception e)
        {
            BeamableLogger.LogError("Error synchronizing inventory for user {gamerTag}, wallet {w}", gamerTag, walletAddress);
            BeamableLogger.LogError(e);
        }
    }

    private async Task<long> GetGamerTag(string walletAddress)
    {
        var account = await _accountsService.SearchAccount(walletAddress);
        if (account is null)
        {
            BeamableLogger.LogError("Account not found for wallet {address}", walletAddress);
            return 0;
        }

        var gamerTag = account.gamerTags
            .Where(x => x.projectId == _beamableRequester.Pid)
            .Select(x => x.gamerTag)
            .FirstOrDefault();

        if (gamerTag == 0)
        {
            BeamableLogger.LogError("Can't find a gamerTag on project {pid} for account {aid}", _beamableRequester.Pid, account.id);
        }

        return gamerTag;
    }
}