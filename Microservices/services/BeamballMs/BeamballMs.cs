using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Lobby;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api.Stats;
using Beamable.Common.Content;
using Beamable.Server;
using Beamable.Server.Api.RealmConfig;
using Newtonsoft.Json;
using UnityEngine;
using Lobby = Beamable.Experimental.Api.Lobbies.Lobby;

namespace Beamable.BeamballMs
{
    [FederationId("default")]
    public class DefaultFederation : IFederationId
    {
    }

    [FederationId("beamball")]
    public class BeamballFederation : IFederationId
    {
    }

    [Microservice("BeamballMs")]
    public partial class BeamballMs : Microservice, IFederatedPlayerInit<DefaultFederation>, IFederatedGameServer<BeamballFederation>
    {
        public async Promise<PlayerInitResult> CreatePlayer(Account account, Dictionary<string, string> properties)
        {
            string name = "Guest User";

            var gamerTag = account.gamerTags[0].gamerTag;

            var userAPI = AssumeNewUser(gamerTag);

            var emailSplited = account.email.GetOrElse($"{name}@").Split("@");
            if (emailSplited.Length > 0) name = emailSplited[0];

            // Add Initial Currency and Skin
            const string defaultSkin = "items.itemskin.skin1";
            const string coinsCurrency = "currency.coins";
            await userAPI.Services.Inventory.AddCurrency(coinsCurrency, 195);
            await userAPI.Services.Inventory.AddItem(defaultSkin, new Dictionary<string, string>() { });
            await userAPI.Services.Stats.SetStats(StatsDomainType.Client, StatsAccessType.Public, gamerTag, new Dictionary<string, string>()
            {
                { "player_name", name },
                { "beamable.selected_skin", defaultSkin }
            });

            return new PlayerInitResult();
        }

        public async Promise<ServerInfo> CreateGameServer(Api.Autogenerated.Models.Lobby lobby)
        {
            var serverInfo = new ServerInfo();
            
            string region = await GetBestRegion(lobby);
            
            // Use this function to parallelize: creating the lobby in your Orchestrator, preparing your lobby's Global Data and PlayerData dictionaries.
            await lobby.PrepareLobbyAsDedicatedServer(serverInfo,
                async l =>
                {
                    // IF the lobby is NOT a fake lobby from playmode, you should be provisioning a server.
                    var connInfo = new ServerInfo();
                    if (!l.IsLobbyFromEditorPlayMode())
                    {
                        var realmConfig = await Services.RealmConfig.GetRealmConfigSettings();

                        // Create the Hathora Room
                        var hathoraRoom = await CreateHathoraGameServer(realmConfig, l.lobbyId.Value, region);

                        // Start polling until its active or the initialization timed out.
                        var pollingInterval = TimeSpan.FromSeconds(1);
                        var startedAt = DateTime.Now;

                        // MaxWaitTime cannot be more than 2 minutes as the current Beamable-enforced timeout is set to 2 minutes.
                        var maxWaitTime = TimeSpan.FromSeconds(60);

                        // Spin for up-to-2-minutes and checking every "PollingInterval" for the connection to become active.
                        while (hathoraRoom.status != "active" && (DateTime.Now - startedAt).TotalSeconds < (maxWaitTime).TotalSeconds)
                        {
                            BeamableLogger.Log($"Room {l.lobbyId.Value} status: {hathoraRoom.status}");
                            await Task.Delay(pollingInterval);
                            hathoraRoom = await PollHathoraGameServer(realmConfig, l.lobbyId.Value);
                        }

                        // It took to long to provision the server.
                        if (hathoraRoom.status != "active")
                        {
                            BeamableLogger.LogError($"Failed to provision game server in time for room. ROOM_ID={l.lobbyId.Value}, LAST_HATHORA_CONN_UPDATE={JsonUtility.ToJson(hathoraRoom)}");
                            throw new MicroserviceException(503, "FAILED_TO_PROVISION_GAME_SERVER_BEFORE_TIMEOUT", JsonUtility.ToJson(hathoraRoom));
                        }

                        // Set the hathora room information as the connection string for this lobby --- the Unreal SDK has utilities to read these properties.
                        // You can always pass them via your own properties.
                        connInfo.SetConnectionString(hathoraRoom.exposedPort.host, hathoraRoom.exposedPort.port.ToString());
                    }

                    return connInfo;
                },
                _ =>
                {
                    // For this specific game, we don't need any global data computed here, but you could compute a map to play in or randomized objects or really anything.
                    return Task.FromResult(new ServerInfo());
                },
                async lp =>
                {
                    // For this game, we need to get the selected skin for each player and put them into the lobby's player data.
                    // You could compute more information such as a selected deck's information and embedded them in this dictionary.
                    // Computing things here and storing them in the lobby is a tradeoff:
                    //   - it allows the game-server to avoid fetching things once it boots up, but it increases the size of the lobby data structure.
                    //   - for most cases, this is a fine trade-off to make; but, think about your own case's specifics as you decided.
                    var data = new Dictionary<string, string>();
                    var existingSkinData = lp.tags.GetOrElse([]).FirstOrDefault(t => t.name.GetOrElse("") == "beamable.selected_skin");
                    if(existingSkinData == null)
                    {
                        var gamerTag = long.Parse(lp.playerId.Value);
                        var selectedSkin = await Services.Stats.GetStat(StatsDomainType.Client, StatsAccessType.Public, gamerTag, "beamable.selected_skin");
                        if(!string.IsNullOrEmpty(selectedSkin))
                        {
                            data["beamable.selected_skin"] = selectedSkin;
                        }
                    }
                    return data;
                });

            // After the lobby is provisioned and wait until the service is ready to notify clients that the match was made.
            // When clients receive this notification, they will be ready to connect.
            await lobby.WaitForGameServerReady(Provider.GetService<IBeamLobbyApi>());

            return serverInfo;
        }

        /// <summary>
        /// Get the best region using the stat in the player stats
        /// </summary>
        /// <param name="lobby"></param>
        /// <returns></returns>
        private async Task<string> GetBestRegion(Api.Autogenerated.Models.Lobby lobby)
        {
            // get the gamer tags of the players in the lobby
            var gamerTags = lobby.players.Value.Select(p => long.Parse(p.playerId)).ToArray();
            
            // This is here to fix an issue that exists in the beamable backend --- the fix should go out "Soon TM".
            // Until this is fixed, every request made from this federated endpoint to "Services.WhateverService" needs to be made through the assumedFakeLeader.
            var assumedFakeLeader = AssumeNewUser(gamerTags.First());

            // get the ping times for each player
            var tasks = new List<Promise<Dictionary<string, string>>>(gamerTags.Length);
            tasks.AddRange(gamerTags.Select(tag => assumedFakeLeader.Services.Stats.GetStats("client", "public", "player", tag, new string[] { Stats.HathoraPings })));
            var pingStats = await Promise.Sequence(tasks);
            
            if (pingStats.Count != 0)
            {
                List<HathoraPingTimes> pings = new List<HathoraPingTimes>();
                foreach (var ping in pingStats)
                {
                    if (ping.TryGetValue(Stats.HathoraPings, out var value))
                    {
                        pings.Add(JsonUtility.FromJson<HathoraPingTimes>(value));
                    }
                }
                
                // Find the best region for this match based on the players in it.
                return GetBestRegion(pings.ToArray());
            }

            return null;
        }

        [ServerCallable]
        public async Task<Dictionary<string, string>> ProcessMatchResult(string winnerId, string lobbyId)
        {
            BeamableLogger.Log("Creating match result for lobby " + lobbyId);

            var beamLobbyApi = Provider.GetService<IBeamLobbyApi>();
            if (!Guid.TryParse(lobbyId, out var lobbyGuid)) throw new MicroserviceException(500, "INVALID_LOBBY_ID", $"Provided Lobby ID was invalid. INVALID={lobbyId}.");

            // We can just fetch the lobby here and check if the winner is in it.
            Api.Autogenerated.Models.Lobby lobby = await beamLobbyApi.Get(lobbyGuid);
            var lobbyPlayers = lobby.players.GetOrElse([]);
            if (lobbyPlayers.All(lp => lp.playerId.Value != winnerId))
            {
                throw new MicroserviceException(500,
                    "WINNER_GAMERTAG_NOT_IN_LOBBY",
                    $"The provided winner's gamertag is not in the lobby. WINNER_ID={winnerId}, LOBBY_PLAYERS={string.Join(",", lobby.players.Value.Select(lp => lp.playerId.Value))}");
            }

            // Create the fake match result and set it in the lobby data
            var properties = new Dictionary<string, string>();
            var updates = new List<Task>();
            foreach (var player in lobbyPlayers)
            {
                var gamerTag = long.Parse(player.playerId.Value);
                var newUser = AssumeNewUser(gamerTag);
                var beamLeaderboardService = newUser.Services.Leaderboards;

                var matchContentId = lobby.matchType.Value.id.Value;
                var matchContent = await Services.Content.GetContent(new ContentRef<SimGameType>(matchContentId));
                var rewards = matchContent.rewards.FirstOrDefault() ?? new RewardsPerRank() { rewards = new() };
                var currencyReward = rewards.rewards.FirstOrDefault() ?? new Reward() { name = "currency.coins", amount = 100 };
                var scoreReward = rewards.rewards.Skip(1).FirstOrDefault() ?? new Reward() { name = "leaderboards.global", amount = 100 };

                properties.Add(player.playerId, scoreReward.amount.ToString());
                updates.Add(beamLeaderboardService.SetScore("leaderboards.global", scoreReward.amount).TaskFromPromise());
                updates.Add(Services.Inventory.SendCurrency(new() { { currencyReward.name, currencyReward.amount } }, gamerTag).TaskFromPromise());
            }

            // Wait for all the score setting and inventory updating requests to finish.
            try
            {
                await Task.WhenAll(updates);
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
                throw;
            }

            // We also set the resulting properties into the lobby so that the game server can replicate these out to clients once it gets the response from this call.
            return properties;
        }

        /// <summary>
        /// Utility function defining defaults and keys for the "hathora_integration" realm-config namespace.
        /// These must be correctly set up in your realm for this microservice to work. 
        /// </summary>
        private static HathoraRealmConfig GetHathoraRealmConfig(RealmConfig config)
        {
            const string kNamespaceHathoraIntegration = "hathora_integration";
            const string kKeyAppID = "app_id";
            const string kKeyDevToken = "dev_token";
            const string kKeyFallbackRegion = "fallback_region";
            const string kKeyHathoraURL = "hathora_url";


            var hathoraRealmConfig = new HathoraRealmConfig
            {
                AppId = config.GetSetting(kNamespaceHathoraIntegration, kKeyAppID),
                DeveloperToken = config.GetSetting(kNamespaceHathoraIntegration, kKeyDevToken),
                FallbackRegion = config.GetSetting(kNamespaceHathoraIntegration, kKeyFallbackRegion, "Seattle"),
                HathoraURL = new Uri(config.GetSetting(kNamespaceHathoraIntegration, kKeyHathoraURL, "https://api.hathora.dev"))
            };

            return hathoraRealmConfig;
        }

        /// <summary>
        /// Takes in the roomId (in our case, the LobbyId) and calls the Hathora API based on realm-config settings and awaits for the response.
        /// </summary>
        private static async Task<HathoraConnectionInfo> CreateHathoraGameServer(RealmConfig config, string roomId, string region = null)
        {
            var hathoraRealmConfig = GetHathoraRealmConfig(config);
            var createUri = new Uri(hathoraRealmConfig.HathoraURL, $"/rooms/v2/{hathoraRealmConfig.AppId}/create?roomId={roomId}");

            var body = new HathoraCreateRoomRequest
            {
                roomConfig = "",
                region = region ?? hathoraRealmConfig.FallbackRegion
            };

            var serialized = JsonUtility.ToJson(body);
            var requestContent = new StringContent(serialized, Encoding.UTF8, "application/json");

            var http = new HttpClient() { DefaultRequestHeaders = { { "Authorization", $"Bearer {hathoraRealmConfig.DeveloperToken}" } } };
            var response = await http.PostAsync(createUri, requestContent);
            var content = await response.Content.ReadAsStringAsync();
            BeamableLogger.Log("Create Room Hathora Response: " + content);
            if (!response.IsSuccessStatusCode)
            {
                throw new Exception(content);
            }

            return JsonUtility.FromJson<HathoraConnectionInfo>(content);
        }

        /// <summary>
        /// Takes in the roomId (in our case, the LobbyId) and calls the Hathora API to get their room's connection information/state.
        /// We use this to wait until the server is provisioned before notifying players that the match is ready.
        /// </summary>
        private static async Task<HathoraConnectionInfo> PollHathoraGameServer(RealmConfig config, string roomId)
        {
            var hathoraRealmConfig = GetHathoraRealmConfig(config);
            var getUri = new Uri(hathoraRealmConfig.HathoraURL, $"/rooms/v2/{hathoraRealmConfig.AppId}/connectioninfo/{roomId}");

            var http = new HttpClient() { DefaultRequestHeaders = { { "Authorization", $"Bearer {hathoraRealmConfig.DeveloperToken}" } } };
            var response = await http.GetAsync(getUri);
            var content = await response.Content.ReadAsStringAsync();
            BeamableLogger.Log("Get ConnectionInfo Hathora Response: " + content);
            if (!response.IsSuccessStatusCode)
            {
                throw new Exception(content);
            }

            return JsonUtility.FromJson<HathoraConnectionInfo>(content);
        }
        
        private static string GetBestRegion(IReadOnlyCollection<HathoraPingTimes> pings)
        {
            if (pings == null || !pings.Any())
                return null;

            var averagePings = pings.Aggregate((a, b) => a + b) / pings.Count;
            var sortedPings = averagePings.GetSortedPingTimes();

            return sortedPings.First().Key;
        }

    }
    public static class Stats
    {
        public const string HathoraPings = "hathora.pings";
    }

    [Serializable]
    public class HathoraRealmConfig
    {
        public string AppId;
        public string DeveloperToken;
        public string FallbackRegion;
        public Uri HathoraURL;
    }

    [Serializable]
    public class HathoraCreateRoomRequest
    {
        public string roomConfig;
        public string region;
    }

    [Serializable]
    public class HathoraPortInfo
    {
        public string host;
        public string name;
        public int port;
        public string transportType;
    }

    [Serializable]
    public class HathoraConnectionInfo
    {
        public string processId;
        public string roomId;
        public string status;
        public HathoraPortInfo exposedPort;
        public List<HathoraPortInfo> additionalExposedPorts;
    }
    
     [Serializable]
    public class HathoraPingTimes
    {
        [JsonProperty("Los_Angeles")] public int LosAngeles;

        [JsonProperty("Chicago")] public int Chicago;

        [JsonProperty("Washington_DC")] public int WashingtonDc;

        [JsonProperty("Seattle")] public int Seattle;

        [JsonProperty("London")] public int London;

        [JsonProperty("Frankfurt")] public int Frankfurt;

        [JsonProperty("Sao_Paulo")] public int SaoPaulo;

        [JsonProperty("Tokyo")] public int Tokyo;

        [JsonProperty("Sydney")] public int Sydney;

        [JsonProperty("Singapore")] public int Singapore;

        [JsonProperty("Mumbai")] public int Mumbai;

        // create a + operator
        public static HathoraPingTimes operator +(HathoraPingTimes a, HathoraPingTimes b)
        {
            return new HathoraPingTimes
            {
                LosAngeles = a.LosAngeles + b.LosAngeles,
                Chicago = a.Chicago + b.Chicago,
                WashingtonDc = a.WashingtonDc + b.WashingtonDc,
                Seattle = a.Seattle + b.Seattle,
                London = a.London + b.London,
                Frankfurt = a.Frankfurt + b.Frankfurt,
                SaoPaulo = a.SaoPaulo + b.SaoPaulo,
                Tokyo = a.Tokyo + b.Tokyo,
                Sydney = a.Sydney + b.Sydney,
                Singapore = a.Singapore + b.Singapore,
                Mumbai = a.Mumbai + b.Mumbai
            };
        }

        public static HathoraPingTimes operator /(HathoraPingTimes a, int b)
        {
            return new HathoraPingTimes
            {
                LosAngeles = a.LosAngeles / b,
                Chicago = a.Chicago / b,
                WashingtonDc = a.WashingtonDc / b,
                Seattle = a.Seattle / b,
                London = a.London / b,
                Frankfurt = a.Frankfurt / b,
                SaoPaulo = a.SaoPaulo / b,
                Tokyo = a.Tokyo / b,
                Sydney = a.Sydney / b,
                Singapore = a.Singapore / b,
                Mumbai = a.Mumbai / b
            };
        }

        public List<KeyValuePair<string, int>> GetSortedPingTimes()
        {
            var pings = new List<KeyValuePair<string, int>>
            {
                new KeyValuePair<string, int>("Los_Angeles", LosAngeles),
                new KeyValuePair<string, int>("Chicago", Chicago),
                new KeyValuePair<string, int>("Washington_DC", WashingtonDc),
                new KeyValuePair<string, int>("Seattle", Seattle),
                new KeyValuePair<string, int>("London", London),
                new KeyValuePair<string, int>("Frankfurt", Frankfurt),
                new KeyValuePair<string, int>("Sao_Paulo", SaoPaulo),
                new KeyValuePair<string, int>("Tokyo", Tokyo),
                new KeyValuePair<string, int>("Sydney", Sydney),
                new KeyValuePair<string, int>("Singapore", Singapore),
                new KeyValuePair<string, int>("Mumbai", Mumbai),
            };

            // Sort the list by ping value
            pings.Sort((firstPair, nextPair) => { return firstPair.Value.CompareTo(nextPair.Value); });

            return pings;
        }
    }
}