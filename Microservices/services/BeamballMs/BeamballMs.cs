using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Lobby;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api.Stats;
using Beamable.Common.Content;
using Beamable.Server;
using Lobby = Beamable.Experimental.Api.Lobbies.Lobby;

namespace Beamable.BeamballMs
{
    [FederationId("default")]
    public class DefaultFederation : IFederationId
    {
    }
    [FederationId("beamball")]
    public class BeamballFederation : IFederationId
    {
    }
    [Microservice("BeamballMs")]
    public partial class BeamballMs : Microservice, IFederatedPlayerInit<DefaultFederation>, IFederatedGameServer<BeamballFederation>
    {
			private const string EmailKey = "__beam_user_email__";
	    
			public async Promise<PlayerInitResult> CreatePlayer(Account account, Dictionary<string, string> properties)
			{
				string name = "GuestUser";
				
				var gamerTag = account.gamerTags[0].gamerTag;
				
				var userAPI = AssumeNewUser(gamerTag);

				if (properties.TryGetValue(EmailKey, out var email))
				{
					var emailSplited = email.Split("@");

					if (emailSplited.Length > 0)
					{
						name = emailSplited[0];
					}
				}
				// Add Initial Currency and Skin
	
				await userAPI.Services.Stats.SetStats(StatsDomainType.Client, StatsAccessType.Public, gamerTag, new Dictionary<string, string>(){{"player_name",name}});

				await userAPI.Services.Inventory.AddCurrency("currency.coins", 100);
				
				await userAPI.Services.Inventory.AddItem("items.itemskin.skin1",new Dictionary<string, string>(){});
				
				return  new PlayerInitResult();
			}
			
			public async Promise<ServerInfo> CreateGameServer(Api.Autogenerated.Models.Lobby lobby)
			{
				// The delay it's just to fake the server creation (when it's pulling the actual server will take some time)
				await Task.Delay(1000);

				var userId = long.Parse(lobby.players.Value[0].playerId);
				
				// We need to assume new user due the fact it is not called by an authenticated context
				var newUser = AssumeNewUser(userId);
				
				// This is a way to fake running the match in the server after 10 seconds it will trigger a server callable 
				// Which is close to an external server calling it with the match result
				await newUser.Services.Scheduler.Schedule().Microservice<BeamballMs>(false)
					.Run(micro => micro.CreateMatchResult, userId, lobby.lobbyId.Value)
					.After(TimeSpan.FromSeconds(10)) // Trigger the method 10 sec
					.Save($"create-result-{lobby.lobbyId}"); // save the job
				
				ServerInfo serverInfo = new ServerInfo()
				{
					globalData = new ()
					{
					},
					playerData = new()
					{
					}
				};
				
				return serverInfo;
			}
			
			[ServerCallable]
			public async Task CreateMatchResult(long userId, string lobbyId)
			{
				BeamableLogger.Log("Creating match result for lobby " + lobbyId);

				// As it is not an authenticated call we need to assume a new user on this
				var newUser = AssumeNewUser(userId);
				
				Random random = new Random();
				
				var beamLobbyApi = newUser.Provider.GetService<IBeamLobbyApi>();
				
				var lobbyGuid = Guid.Parse(lobbyId);
				
				Api.Autogenerated.Models.Lobby lobby = await beamLobbyApi.Get(lobbyGuid);

				Dictionary<string, string> properties = new Dictionary<string, string>();

				// Create the fake match result and set it in the lobby data
				if (lobby.players.HasValue)
				{
					foreach (var player in lobby.players.Value)
					{
						var newUserLeaderboard = AssumeNewUser(long.Parse(player.playerId.Value));
						var beamLeaderboardService = newUserLeaderboard.Services.Leaderboards;
						
						var score = random.Next(3, 35);
						properties.Add(player.playerId, score.ToString());
						await beamLeaderboardService.SetScore("leaderboards.global", score);
					}
				}
				
				
				
				await beamLobbyApi.PutMetadata(lobbyGuid, new UpdateLobby
				{
					data = new OptionalUpdateData(new UpdateData()
					{
						updates = new OptionalMapOfString(properties)
					})
				});
			}
			
    }
}
