using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Server;
using Beamable.Server.Api.Notifications;
using Beamable.Server.Api.RealmConfig;
using Beamable.Server.Api.Stats;
using Discord;
using Discord.WebSocket;
using UnityEngine;
using EmptyResponse = Beamable.Common.Api.EmptyResponse;

namespace Beamable.DiscordSampleMs;

[FederationId("discord")]
public class DiscordId : IFederationId;

[Microservice("DiscordSampleMs")]
public partial class DiscordSampleMs : Microservice, IFederatedLogin<DiscordId>
{
    [Serializable]
    public class DiscordWhitelistedInfo
    {
        public bool matchmaking_discord_whitelisted;
    }

    [ConfigureServices]
    public static void Configure(IServiceBuilder builder)
    {
        // Services
        builder.Builder.AddSingleton<DiscordBot>();
    }

    [InitializeServices]
    public static async Task Init(IServiceInitializer init)
    {
        var discordBot = init.GetService<DiscordBot>();
        await discordBot.Connect();
    }

    public async Promise<FederatedAuthenticationResponse> Authenticate(string token, string challenge, string solution)
    {
        var discordUserFromToken = await Requests.GetDiscordUserFromToken(token);
        if (discordUserFromToken == null) throw new UnauthorizedAccessException($"Invalid Discord Token");

        // INFO: When we are signing in with an external identity, the UserId isn't filled in since the Login Request is not an Authenticated request.
        // INFO: When attaching, this UserId is filled, so we can skip this request.
        var discordRealmConfig = await Requests.GetDiscordRealmConfig(Services.RealmConfig);
        var gamerTag = Context.UserId;
        if (gamerTag == 0)
        {
            // Get Beamable account from Discord User Id
            var beamableAccount = await Requests.GetBeamableAccountFromDiscordId(Requester, discordUserFromToken.id);

            // Find the gamer tag for this realm
            var gamerTagAssociation = beamableAccount.gamerTags.FirstOrDefault(association => association.projectId == Requester.Pid);

            // No gamer tag found for this user in this realm.
            if (gamerTagAssociation != null)
            {
                gamerTag = gamerTagAssociation.gamerTag;
            }
            else
            {
                BeamableLogger.LogWarning($"This user has no GamerTag in this Realm, but has in another", Requester.Pid);
            }
        }

        // If we found a gamer-tag, let's just initialize the discord role flag based on whether or not this user  
        // has an allowed role.
        // TODO: The GamerTag will eventually be guaranteed to exist here and this C#MS code won't be needed to special-case this.   
        if (gamerTag != 0)
        {
            // Update the stat for the authenticating user
            var discordGuildUser = await Requests.GetGuildUserById(discordRealmConfig.BotToken, discordRealmConfig.GuildId, discordUserFromToken.id);
            var isWhitelisted = IsDiscordUserWhitelistedForMatchmaking(discordGuildUser, discordRealmConfig);
            Log.Warning("Attaching [Discord UserId = {UserId}] to [GamerTag = {BeamableId}].{Whitelist}", discordUserFromToken.id, gamerTag, isWhitelisted ? $"User Whitelisted." : "User Not Whitelisted");

            using var requestingUser = AssumeNewUser(gamerTag);
            await requestingUser.Services.Stats.SetStats("game", "private", "player", gamerTag, new()
            {
                { "matchmaking_discord_whitelisted", $"{isWhitelisted}" },
            });
        }

        return new FederatedAuthenticationResponse()
        {
            user_id = discordUserFromToken.id,
        };
    }

    [ClientCallable, SwaggerCategory("discord")]
    public async Task<bool> UpdateFromDiscord()
    {
        var discordRealmConfig = await Requests.GetDiscordRealmConfig(Services.RealmConfig);
        var gamerTag = Context.UserId;

        var beamableUser = await Services.Auth.GetUser(gamerTag);
        var discordUserId = beamableUser.external.FirstOrDefault(identity => identity.providerNamespace == "discord")?.userId;

        if (string.IsNullOrEmpty(discordUserId))
            return false;

        var discordGuildUser = await Requests.GetGuildUserById(discordRealmConfig.BotToken, discordRealmConfig.GuildId, discordUserId);
        var isWhitelisted = IsDiscordUserWhitelistedForMatchmaking(discordGuildUser, discordRealmConfig);
        Log.Warning("Updating User Matchmaking Whitelist State [GamerTag = {BeamableId}].{Whitelist}", gamerTag, isWhitelisted ? $"User Whitelisted." : "User Not Whitelisted");

        await Services.Stats.SetStats("game", "private", "player", gamerTag, new()
        {
            { "matchmaking_discord_whitelisted", $"{isWhitelisted}" }
        });
        await Services.Notifications.NotifyUser(gamerTag, isWhitelisted);

        return isWhitelisted;
    }

    [ClientCallable, SwaggerCategory("discord")]
    public async Task<DiscordWhitelistedInfo> UpdateUserWhitelistedStatus()
    {
        var whitelistedStat = await Services.Stats.GetProtectedPlayerStat(Context.UserId, "matchmaking_discord_whitelisted");
        Debug.Log($"{Context.UserId} whitelistedStat: {whitelistedStat}");
        var isWhitelisted = !string.IsNullOrWhiteSpace(whitelistedStat) && whitelistedStat.Equals("true", StringComparison.InvariantCultureIgnoreCase);
        return new DiscordWhitelistedInfo() { matchmaking_discord_whitelisted = isWhitelisted };
    }


    private static bool IsDiscordUserWhitelistedForMatchmaking(DiscordGuildUser discordGuildUser,
        DiscordRealmConfig discordRealmConfig)
    {
        return discordGuildUser?.roles != null && discordGuildUser.roles.Intersect(discordRealmConfig.RoleIds).Any();
    }
}

public class DiscordBot
{
    private readonly IBeamableRequester _beamableRequester;
    private readonly IMicroserviceRealmConfigService _beamableConfigService;
    private readonly IMicroserviceStatsApi _beamableStatsService;
    private readonly IMicroserviceNotificationsApi _notificationsApi;
    private readonly DiscordSocketClient _discordClient;

    public DiscordBot(IBeamableRequester requester, IMicroserviceRealmConfigService realmConfigService,
        IMicroserviceStatsApi statsService, IMicroserviceNotificationsApi notificationsApi)
    {
        _beamableRequester = requester;
        _beamableConfigService = realmConfigService;
        _beamableStatsService = statsService;
        _notificationsApi = notificationsApi;

        _discordClient = new DiscordSocketClient(
            new DiscordSocketConfig
            {
                AlwaysDownloadUsers = true,
                GatewayIntents = GatewayIntents.Guilds | GatewayIntents.GuildMembers,
            }
        );

        _discordClient.Log += OnLog; // Debug purposes
        _discordClient.Ready += OnReady;
        _discordClient.Disconnected += OnDisconnected;
        _discordClient.GuildMemberUpdated += OnGuildMemberUpdated;
    }

    private Task OnDisconnected(Exception arg)
    {
        BeamableLogger.LogException(arg);
        return Task.CompletedTask;
    }

    public async Task Connect()
    {
        if (_discordClient.ConnectionState == ConnectionState.Disconnected)
        {
            var discordRealmConfig = await Requests.GetDiscordRealmConfig(_beamableConfigService);
            var botToken = discordRealmConfig.BotToken;
            var rolesConfig = discordRealmConfig.RoleIds;
            if (string.IsNullOrEmpty(botToken))
            {
                BeamableLogger.LogWarning("Discord Bot Token not configured. Connection Aborted!");
                return;
            }

            if (rolesConfig.Count == 0)
            {
                BeamableLogger.LogWarning("Discord Roles whitelist is empty. Connection Aborted!");
                return;
            }

            await _discordClient.LoginAsync(TokenType.Bot, botToken);
            await _discordClient.StartAsync();
            await _discordClient.SetStatusAsync(UserStatus.Online);
            await _discordClient.SetGameAsync("status");
        }
    }

    private Task OnReady()
    {
        BeamableLogger.Log($"Connected to discord servers: {string.Join(", ", _discordClient.Guilds)}");
        return Task.CompletedTask;
    }

    // Debug Logging of received messages
    private Task OnLog(LogMessage msg)
    {
        BeamableLogger.Log($"{msg}\n");
        return Task.CompletedTask;
    }

    private async Task OnGuildMemberUpdated(Cacheable<SocketGuildUser, ulong> cachedUser, SocketGuildUser postUpdateUser)
    {
        BeamableLogger.Log("Role has changed!");
        if (cachedUser.HasValue)
        {
            if (cachedUser.Value.Roles.Count != postUpdateUser.Roles.Count)
            {
                var roles = postUpdateUser.Roles.Select(role => role.Name);
                // Roles of the user has changed
                BeamableLogger.Log($"Role has changed for user: {postUpdateUser.Id}");
                BeamableLogger.Log($"Roles: {string.Join(",", roles)}");

                var config = await Requests.GetDiscordRealmConfig(_beamableConfigService);
                var hasAccess = postUpdateUser.Roles.Any(role => config.RoleIds.Contains(role.Id.ToString()));

                await UpdateAccess(cachedUser.Value, hasAccess);
            }
        }
    }

    private async Task UpdateAccess(SocketGuildUser discordUser, bool hasAccess)
    {
        var discordUserId = discordUser.Id.ToString();
        try
        {
            var account = await Requests.GetBeamableAccountFromDiscordId(_beamableRequester, discordUserId);
            var gamerTagAssociation = account.gamerTags.FirstOrDefault(association => association.projectId == _beamableRequester.Pid);

            // No gamer tag found for this user in this realm.
            if (gamerTagAssociation == null)
                return;

            await _beamableStatsService.SetStats("game", "private", "player", gamerTagAssociation.gamerTag,
                new Dictionary<string, string>
                {
                    { "matchmaking_discord_whitelisted", hasAccess.ToString() }
                }
            );
            await _notificationsApi.NotifyUser(gamerTagAssociation.gamerTag, hasAccess);
            var discordRealmConfig = await Requests.GetDiscordRealmConfig(_beamableConfigService);
            if (discordRealmConfig.NotifyChannel == 0)
                return;

            var channel = await _discordClient.GetChannelAsync(discordRealmConfig.NotifyChannel);
            if (channel is IMessageChannel messageChannel)
            {
                await messageChannel.SendMessageAsync($"{discordUser.Mention} Updated matchmaking status: {(hasAccess ? "access gained" : "access denied")}");
            }

            BeamableLogger.Log($"Updated Access for Beamable PlayerId '{gamerTagAssociation.gamerTag}', Discord UserId '{discordUserId}' to '{hasAccess}'."
            );
        }
        catch (WebsocketRequesterException ex) when (ex.Status == 404)
        {
            // Account Not Found
            BeamableLogger.Log($"No Beamable account found for Discord UserId '{discordUserId}'.");
        }
    }
}

public static class Requests
{
    [Serializable]
    private class GetAccountRequest
    {
        public ExternalAccount external;

        public GetAccountRequest(string providerService, string providerNamespace, string userId)
        {
            external = new ExternalAccount
            {
                providerService = providerService,
                providerNamespace = providerNamespace,
                userId = userId
            };
        }
    }

    public static Promise<EmptyResponse> NotifyUser(this IMicroserviceNotificationsApi api, long gamerTag,
        bool isWhitelisted)
    {
        var value = JsonUtility.ToJson(new DiscordSampleMs.DiscordWhitelistedInfo
            { matchmaking_discord_whitelisted = isWhitelisted });
        BeamableLogger.Log($"Notify player {gamerTag} that whitelisted value is: {value}");
        return api.NotifyPlayer(gamerTag, "matchmaking_refresh",
            new DiscordSampleMs.DiscordWhitelistedInfo { matchmaking_discord_whitelisted = isWhitelisted });
    }

    public static Promise<BeamableAccount> GetBeamableAccountFromDiscordId(IBeamableRequester beamableRequester,
        string discordUserId)
    {
        return beamableRequester.Request<BeamableAccount>(
            Method.GET,
            "/basic/accounts",
            new GetAccountRequest(nameof(DiscordSampleMs), "discord", discordUserId),
            includeAuthHeader: false);
    }

    public static async Task<DiscordGuildUser> GetGuildUserById(string botToken, string guildId, string userId)
    {
        using var httpClient = new HttpClient();
        httpClient.DefaultRequestHeaders.Add("Authorization", $"Bot {botToken}");
        var response = await httpClient.GetAsync($"https://discord.com/api/v10/guilds/{guildId}/members/{userId}");

        var asStr = await response.Content.ReadAsStringAsync();
        Log.Warning("Discord Get Current Guild User Raw Response = {RawResponse}", asStr);

        if (!response.IsSuccessStatusCode)
            return null;

        try
        {
            var discordGuildUser = JsonUtility.FromJson<DiscordGuildUser>(asStr);
            return discordGuildUser;
        }
        catch (Exception)
        {
            return null;
        }
    }

    public static async Task<DiscordGuild> GetGuildInfo(string botToken, string guildId)
    {
        using var httpClient = new HttpClient();
        httpClient.DefaultRequestHeaders.Add("Authorization", $"Bot {botToken}");
        var response = await httpClient.GetAsync($"https://discord.com/api/v10/guilds/{guildId}");

        var asStr = await response.Content.ReadAsStringAsync();
        Log.Warning("Discord Get Current Guild User Raw Response = {RawResponse}", asStr);

        if (!response.IsSuccessStatusCode)
            return null;

        try
        {
            var discordGuildUser = JsonUtility.FromJson<DiscordGuild>(asStr);
            return discordGuildUser;
        }
        catch (Exception)
        {
            return null;
        }
    }

    public static async Task<DiscordUser> GetDiscordUserFromToken(string token)
    {
        using var httpClient = new HttpClient();
        httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {token}");
        var response = await httpClient.GetAsync("https://discord.com/api/v10/users/@me");

        var asStr = await response.Content.ReadAsStringAsync();
        Log.Warning("Discord Raw Response = {RawResponse}", asStr);

        // If we failed to get a valid user with the given token, we fail the verification
        if (!response.IsSuccessStatusCode) return null;

        // We ensure that the response is formatted as expected and that we can parse the data we need from it.
        // If we can't, we fail the request.
        try
        {
            var discordUser = JsonUtility.FromJson<DiscordUser>(asStr);
            return discordUser;
        }
        catch (Exception)
        {
            return null;
        }
    }

    public static async Task<DiscordRealmConfig> GetDiscordRealmConfig(
        IMicroserviceRealmConfigService realmConfigService)
    {
        var realmConfig = await realmConfigService.GetRealmConfigSettings();
        var discordRealmConfig = realmConfig.GetNamespace("discord_integration");
        var notifyChannelSetting = discordRealmConfig.GetSetting("notify_channel");
        return new DiscordRealmConfig
        {
            BotToken = discordRealmConfig.GetSetting("bot_token"),
            GuildId = discordRealmConfig.GetSetting("guild_id"),
            NotifyChannel = ulong.TryParse(notifyChannelSetting, out var value) ? value : 0,
            RoleIds = discordRealmConfig.GetSetting("matchmaking_roles_whitelist")?.Trim().Split(",").ToHashSet() ??
                      [],
        };
    }
}

[Serializable]
public class DiscordUser
{
    public string id;
    public string username;
    public string global_name;
    public string avatar;
    public string discriminator;
    public int public_flags;
    public int flags;
    public string banner;
    public string accent_color;
    public string locale;
    public bool mfa_enabled;
    public int premium_type;
    public string avatar_decoration;
    public string email;
    public bool verified;
}

public class DiscordRealmConfig
{
    public string BotToken;
    public string GuildId;
    public ulong NotifyChannel;
    public HashSet<string> RoleIds;
}

[Serializable]
public class DiscordGuildUser
{
    public DiscordUser user;
    public string[] roles;
}

[Serializable]
public class DiscordGuildRole
{
    public string id;
    public string name;
}

[Serializable]
public class BeamableAccount
{
    public GamerTagAssociation[] gamerTags;
}

[Serializable]
public class ExternalAccount
{
    public string providerService;
    public string providerNamespace;
    public string userId;
}

[Serializable]
public class DiscordGuild
{
    public string id;
    public string name;
    public string icon;
    public string description;
    public string splash;
    public long approximate_member_count;
    public long approximate_presence_count;
    public string[] features;
    public DiscordRole[] roles;
}

[Serializable]
public class DiscordRole
{
    public string id;
    public string name;
    public string permissions;
    public long position;
    public long color;
    public bool hoist;
}